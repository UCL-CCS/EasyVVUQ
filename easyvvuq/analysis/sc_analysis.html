<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="pdoc 7.1.0" />
    <title>easyvvuq.analysis.sc_analysis API documentation</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2264%22%20height%3D%2264%22%20viewBox%3D%2244.5%202.5%2015%2015%22%3E%3Cpath%20d%3D%22M49.351%2021.041c-.233-.721-.546-2.408-.772-4.076-.042-.09-.067-.187-.046-.288-.166-1.347-.277-2.625-.241-3.351-1.378-1.008-2.271-2.586-2.271-4.362%200-.976.272-1.935.788-2.774.057-.094.122-.18.184-.268-.033-.167-.052-.339-.052-.516%200-1.477%201.202-2.679%202.679-2.679.791%200%201.496.352%201.987.9a6.3%206.3%200%200%201%201.001.029c.492-.564%201.207-.929%202.012-.929%201.477%200%202.679%201.202%202.679%202.679a2.65%202.65%200%200%201-.269%201.148c.383.747.595%201.572.595%202.41%200%202.311-1.507%204.29-3.635%205.107.037.699.147%202.27.423%203.294l.137.461c.156%202.136-4.612%205.166-5.199%203.215zm.127-4.919a4.78%204.78%200%200%200%20.775-.584c-.172-.115-.505-.254-.88-.378zm.331%202.302l.828-.502c-.202-.143-.576-.328-.984-.49zm.45%202.157l.701-.403c-.214-.115-.536-.249-.891-.376l.19.779zM49.13%204.141c0%20.152.123.276.276.276s.275-.124.275-.276-.123-.276-.276-.276-.275.124-.275.276zm.735-.389a1.15%201.15%200%200%201%20.314.783%201.16%201.16%200%200%201-1.162%201.162c-.457%200-.842-.27-1.032-.653-.026.117-.042.238-.042.362a1.68%201.68%200%200%200%201.679%201.679%201.68%201.68%200%200%200%201.679-1.679c0-.843-.626-1.535-1.436-1.654zm3.076%201.654a1.68%201.68%200%200%200%201.679%201.679%201.68%201.68%200%200%200%201.679-1.679c0-.037-.009-.072-.011-.109-.21.3-.541.508-.935.508a1.16%201.16%200%200%201-1.162-1.162%201.14%201.14%200%200%201%20.474-.912c-.015%200-.03-.005-.045-.005-.926.001-1.679.754-1.679%201.68zm1.861-1.265c0%20.152.123.276.276.276s.275-.124.275-.276-.123-.276-.276-.276-.275.124-.275.276zm1.823%204.823c0-.52-.103-1.035-.288-1.52-.466.394-1.06.64-1.717.64-1.144%200-2.116-.725-2.499-1.738-.383%201.012-1.355%201.738-2.499%201.738-.867%200-1.631-.421-2.121-1.062-.307.605-.478%201.267-.478%201.942%200%202.486%202.153%204.51%204.801%204.51s4.801-2.023%204.801-4.51zm-3.032%209.156l-.146-.492c-.276-1.02-.395-2.457-.444-3.268a6.11%206.11%200%200%201-1.18.115%206.01%206.01%200%200%201-2.536-.562l.006.175c.802.215%201.848.612%202.021%201.25.079.295-.021.601-.274.837l-.598.501c.667.304%201.243.698%201.311%201.179.02.144.022.507-.393.787l-.564.365c1.285.521%201.361.96%201.381%201.126.018.142.011.496-.427.746l-.854.489c.064-1.19%201.985-2.585%202.697-3.248zM49.34%209.925c0-.667%201-.667%201%200%200%20.653.818%201.205%201.787%201.205s1.787-.552%201.787-1.205c0-.667%201-.667%201%200%200%201.216-1.25%202.205-2.787%202.205s-2.787-.989-2.787-2.205zm-.887-7.633c-.093.077-.205.114-.317.114a.5.5%200%200%201-.318-.886L49.183.397a.5.5%200%200%201%20.703.068.5.5%200%200%201-.069.703zm7.661-.065c-.086%200-.173-.022-.253-.068l-1.523-.893c-.575-.337-.069-1.2.506-.863l1.523.892a.5.5%200%200%201%20.179.685c-.094.158-.261.247-.432.247z%22%20fill%3D%22%233bb300%22/%3E%3C/svg%3E"/>


<style>/*! * Bootstrap Reboot v5.0.0 (https://getbootstrap.com/) * Copyright 2011-2021 The Bootstrap Authors * Copyright 2011-2021 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE) * Forked from Normalize.css, licensed MIT (https://github.com/necolas/normalize.css/blob/master/LICENSE.md) */*,::after,::before{box-sizing:border-box}@media (prefers-reduced-motion:no-preference){:root{scroll-behavior:smooth}}body{margin:0;font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans","Liberation Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";font-size:1rem;font-weight:400;line-height:1.5;color:#212529;background-color:#fff;-webkit-text-size-adjust:100%;-webkit-tap-highlight-color:transparent}hr{margin:1rem 0;color:inherit;background-color:currentColor;border:0;opacity:.25}hr:not([size]){height:1px}h1,h2,h3,h4,h5,h6{margin-top:0;margin-bottom:.5rem;font-weight:500;line-height:1.2}h1{font-size:calc(1.375rem + 1.5vw)}@media (min-width:1200px){h1{font-size:2.5rem}}h2{font-size:calc(1.325rem + .9vw)}@media (min-width:1200px){h2{font-size:2rem}}h3{font-size:calc(1.3rem + .6vw)}@media (min-width:1200px){h3{font-size:1.75rem}}h4{font-size:calc(1.275rem + .3vw)}@media (min-width:1200px){h4{font-size:1.5rem}}h5{font-size:1.25rem}h6{font-size:1rem}p{margin-top:0;margin-bottom:1rem}abbr[data-bs-original-title],abbr[title]{-webkit-text-decoration:underline dotted;text-decoration:underline dotted;cursor:help;-webkit-text-decoration-skip-ink:none;text-decoration-skip-ink:none}address{margin-bottom:1rem;font-style:normal;line-height:inherit}ol,ul{padding-left:2rem}dl,ol,ul{margin-top:0;margin-bottom:1rem}ol ol,ol ul,ul ol,ul ul{margin-bottom:0}dt{font-weight:700}dd{margin-bottom:.5rem;margin-left:0}blockquote{margin:0 0 1rem}b,strong{font-weight:bolder}small{font-size:.875em}mark{padding:.2em;background-color:#fcf8e3}sub,sup{position:relative;font-size:.75em;line-height:0;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}a{color:#0d6efd;text-decoration:underline}a:hover{color:#0a58ca}a:not([href]):not([class]),a:not([href]):not([class]):hover{color:inherit;text-decoration:none}code,kbd,pre,samp{font-family:SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;font-size:1em;direction:ltr;unicode-bidi:bidi-override}pre{display:block;margin-top:0;margin-bottom:1rem;overflow:auto;font-size:.875em}pre code{font-size:inherit;color:inherit;word-break:normal}code{font-size:.875em;color:#d63384;word-wrap:break-word}a>code{color:inherit}kbd{padding:.2rem .4rem;font-size:.875em;color:#fff;background-color:#212529;border-radius:.2rem}kbd kbd{padding:0;font-size:1em;font-weight:700}figure{margin:0 0 1rem}img,svg{vertical-align:middle}table{caption-side:bottom;border-collapse:collapse}caption{padding-top:.5rem;padding-bottom:.5rem;color:#6c757d;text-align:left}th{text-align:inherit;text-align:-webkit-match-parent}tbody,td,tfoot,th,thead,tr{border-color:inherit;border-style:solid;border-width:0}label{display:inline-block}button{border-radius:0}button:focus:not(:focus-visible){outline:0}button,input,optgroup,select,textarea{margin:0;font-family:inherit;font-size:inherit;line-height:inherit}button,select{text-transform:none}[role=button]{cursor:pointer}select{word-wrap:normal}select:disabled{opacity:1}[list]::-webkit-calendar-picker-indicator{display:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button}[type=button]:not(:disabled),[type=reset]:not(:disabled),[type=submit]:not(:disabled),button:not(:disabled){cursor:pointer}::-moz-focus-inner{padding:0;border-style:none}textarea{resize:vertical}fieldset{min-width:0;padding:0;margin:0;border:0}legend{float:left;width:100%;padding:0;margin-bottom:.5rem;font-size:calc(1.275rem + .3vw);line-height:inherit}@media (min-width:1200px){legend{font-size:1.5rem}}legend+*{clear:left}::-webkit-datetime-edit-day-field,::-webkit-datetime-edit-fields-wrapper,::-webkit-datetime-edit-hour-field,::-webkit-datetime-edit-minute,::-webkit-datetime-edit-month-field,::-webkit-datetime-edit-text,::-webkit-datetime-edit-year-field{padding:0}::-webkit-inner-spin-button{height:auto}[type=search]{outline-offset:-2px;-webkit-appearance:textfield}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-color-swatch-wrapper{padding:0}::file-selector-button{font:inherit}::-webkit-file-upload-button{font:inherit;-webkit-appearance:button}output{display:inline-block}iframe{border:0}summary{display:list-item;cursor:pointer}progress{vertical-align:baseline}[hidden]{display:none!important}</style>
<style>/*! pygments syntax highlighting */pre{line-height:125%;}td.linenos pre{color:#000000; background-color:#f0f0f0; padding-left:5px; padding-right:5px;}span.linenos{color:#000000; background-color:#f0f0f0; padding-left:5px; padding-right:5px;}td.linenos pre.special{color:#000000; background-color:#ffffc0; padding-left:5px; padding-right:5px;}span.linenos.special{color:#000000; background-color:#ffffc0; padding-left:5px; padding-right:5px;}.pdoc .hll{background-color:#ffffcc}.pdoc{background:#f8f8f8;}.pdoc .c{color:#408080; font-style:italic}.pdoc .err{border:1px solid #FF0000}.pdoc .k{color:#008000; font-weight:bold}.pdoc .o{color:#666666}.pdoc .ch{color:#408080; font-style:italic}.pdoc .cm{color:#408080; font-style:italic}.pdoc .cp{color:#BC7A00}.pdoc .cpf{color:#408080; font-style:italic}.pdoc .c1{color:#408080; font-style:italic}.pdoc .cs{color:#408080; font-style:italic}.pdoc .gd{color:#A00000}.pdoc .ge{font-style:italic}.pdoc .gr{color:#FF0000}.pdoc .gh{color:#000080; font-weight:bold}.pdoc .gi{color:#00A000}.pdoc .go{color:#888888}.pdoc .gp{color:#000080; font-weight:bold}.pdoc .gs{font-weight:bold}.pdoc .gu{color:#800080; font-weight:bold}.pdoc .gt{color:#0044DD}.pdoc .kc{color:#008000; font-weight:bold}.pdoc .kd{color:#008000; font-weight:bold}.pdoc .kn{color:#008000; font-weight:bold}.pdoc .kp{color:#008000}.pdoc .kr{color:#008000; font-weight:bold}.pdoc .kt{color:#B00040}.pdoc .m{color:#666666}.pdoc .s{color:#BA2121}.pdoc .na{color:#7D9029}.pdoc .nb{color:#008000}.pdoc .nc{color:#0000FF; font-weight:bold}.pdoc .no{color:#880000}.pdoc .nd{color:#AA22FF}.pdoc .ni{color:#999999; font-weight:bold}.pdoc .ne{color:#D2413A; font-weight:bold}.pdoc .nf{color:#0000FF}.pdoc .nl{color:#A0A000}.pdoc .nn{color:#0000FF; font-weight:bold}.pdoc .nt{color:#008000; font-weight:bold}.pdoc .nv{color:#19177C}.pdoc .ow{color:#AA22FF; font-weight:bold}.pdoc .w{color:#bbbbbb}.pdoc .mb{color:#666666}.pdoc .mf{color:#666666}.pdoc .mh{color:#666666}.pdoc .mi{color:#666666}.pdoc .mo{color:#666666}.pdoc .sa{color:#BA2121}.pdoc .sb{color:#BA2121}.pdoc .sc{color:#BA2121}.pdoc .dl{color:#BA2121}.pdoc .sd{color:#BA2121; font-style:italic}.pdoc .s2{color:#BA2121}.pdoc .se{color:#BB6622; font-weight:bold}.pdoc .sh{color:#BA2121}.pdoc .si{color:#BB6688; font-weight:bold}.pdoc .sx{color:#008000}.pdoc .sr{color:#BB6688}.pdoc .s1{color:#BA2121}.pdoc .ss{color:#19177C}.pdoc .bp{color:#008000}.pdoc .fm{color:#0000FF}.pdoc .vc{color:#19177C}.pdoc .vg{color:#19177C}.pdoc .vi{color:#19177C}.pdoc .vm{color:#19177C}.pdoc .il{color:#666666}</style>
<style>/*! pdoc */:root{--pdoc-background:#fff;}.pdoc{--text:#212529;--muted:#6c757d;--link:#3660a5;--link-hover:#1659c5;--code:#f7f7f7;--active:#fff598;--accent:#eee;--accent2:#c1c1c1;--nav-hover:rgba(255, 255, 255, 0.5);--name:#0066BB;--def:#008800;--annotation:#007020;}body{background-color:var(--pdoc-background);}html, body{width:100%;height:100%;}@media (max-width:769px){#navtoggle{cursor:pointer;position:absolute;width:50px;height:40px;top:1rem;right:1rem;border-color:var(--text);color:var(--text);display:flex;opacity:0.8;}#navtoggle:hover{opacity:1;}#togglestate + div{display:none;}#togglestate:checked + div{display:inherit;}main, header{padding:2rem 3vw;}.git-button{display:none !important;}nav input[type="search"]:valid ~ *{display:none !important;}}@media (min-width:770px){:root{--sidebar-width:clamp(12.5rem, 28vw, 22rem);}nav{position:fixed;overflow:auto;height:100vh;width:var(--sidebar-width);}main, header{padding:3rem 2rem 3rem calc(var(--sidebar-width) + 3rem);width:calc(54rem + var(--sidebar-width));max-width:100%;}#navtoggle{display:none;}}#togglestate{display:none;}nav.pdoc{--pad:1.75rem;--indent:1.5rem;background-color:var(--accent);border-right:1px solid var(--accent2);box-shadow:0 0 20px rgba(50, 50, 50, .2) inset;padding:0 0 0 var(--pad);overflow-wrap:anywhere;scrollbar-width:thin; scrollbar-color:var(--accent2) transparent }nav.pdoc::-webkit-scrollbar{width:.4rem; }nav.pdoc::-webkit-scrollbar-thumb{background-color:var(--accent2); }nav.pdoc > div{padding:var(--pad) 0;}nav.pdoc .module-list-button{display:inline-flex;align-items:center;color:var(--text);border-color:var(--muted);margin-bottom:1rem;}nav.pdoc .module-list-button:hover{border-color:var(--text);}nav.pdoc input[type=search]{display:block;outline-offset:0;width:calc(100% - var(--pad));}nav.pdoc ul{list-style:none;padding-left:0;}nav.pdoc li{display:block;margin:0;padding:.2rem 0 .2rem var(--indent);transition:all 100ms;}nav.pdoc > div > ul > li{padding-left:0;}nav.pdoc li:hover{background-color:var(--nav-hover);}nav.pdoc a, nav.pdoc a:hover{color:var(--text);}nav.pdoc a{display:block;}nav.pdoc > h2:first-of-type{margin-top:1.5rem;}nav.pdoc .class:before{content:"class ";color:var(--muted);}nav.pdoc .function:after{content:"()";color:var(--muted);}html, main{scroll-behavior:smooth;}.pdoc{color:var(--text);box-sizing:border-box;line-height:1.5;background:none;}.pdoc .pdoc-button{display:inline-block;border:solid black 1px;border-radius:2px;font-size:.75rem;padding:calc(0.5em - 1px) 1em;transition:100ms all;}.pdoc .visually-hidden{position:absolute !important;width:1px !important;height:1px !important;padding:0 !important;margin:-1px !important;overflow:hidden !important;clip:rect(0, 0, 0, 0) !important;white-space:nowrap !important;border:0 !important;}.pdoc h1, .pdoc h2, .pdoc h3{font-weight:300;margin:.3em 0;padding:.2em 0;}.pdoc a{text-decoration:none;color:var(--link);}.pdoc a:hover{color:var(--link-hover);}.pdoc blockquote{margin-left:2rem;}.pdoc pre{background-color:var(--code);border-top:1px solid var(--accent2);border-bottom:1px solid var(--accent2);margin-bottom:1em;padding:.5rem 0 .5rem .5rem;overflow-x:auto;}.pdoc code{color:var(--text);padding:.2em .4em;margin:0;font-size:85%;background-color:var(--code);border-radius:6px;}.pdoc a > code{color:inherit;}.pdoc pre > code{display:inline-block;font-size:inherit;background:none;border:none;padding:0;}.pdoc .modulename{margin-top:0;font-weight:bold;}.pdoc .modulename a{color:var(--link);transition:100ms all;}.pdoc .git-button{float:right;border:solid var(--link) 1px;}.pdoc .git-button:hover{background-color:var(--link);color:var(--pdoc-background);}.pdoc details{--shift:-40px;text-align:right;margin-top:var(--shift);margin-bottom:calc(0px - var(--shift));clear:both;filter:opacity(1);}.pdoc details:not([open]){height:0;overflow:visible;}.pdoc details > summary{font-size:.75rem;cursor:pointer;color:var(--muted);border-width:0;padding:0 .7em;display:inline-block;display:inline list-item;user-select:none;}.pdoc details > summary:focus{outline:0;}.pdoc details > div{margin-top:calc(0px - var(--shift) / 2);text-align:left;}.pdoc .docstring{margin-bottom:1.5rem;}.pdoc > section:first-of-type > .docstring{margin-bottom:3rem;}.pdoc .docstring pre{margin-left:1em;margin-right:1em;}.pdoc h1:target,.pdoc h2:target,.pdoc h3:target,.pdoc h4:target,.pdoc h5:target,.pdoc h6:target{background-color:var(--active);box-shadow:-1rem 0 0 0 var(--active);}.pdoc div:target > .attr,.pdoc section:target > .attr,.pdoc dd:target > a{background-color:var(--active);}.pdoc .attr:hover{filter:contrast(0.95);}.pdoc .headerlink{position:absolute;width:0;margin-left:-1.5rem;line-height:1.4rem;font-size:1.5rem;font-weight:normal;transition:all 100ms ease-in-out;opacity:0;}.pdoc .attr > .headerlink{margin-left:-2.5rem;}.pdoc *:hover > .headerlink,.pdoc *:target > .attr > .headerlink{opacity:1;}.pdoc .attr{display:block;color:var(--text);margin:1rem 0 .5rem;padding:.4rem 5rem .4rem 1rem;background-color:var(--accent);}.pdoc .classattr{margin-left:2rem;}.pdoc .name{color:var(--name);font-weight:bold;}.pdoc .def{color:var(--def);font-weight:bold;}.pdoc .signature{white-space:pre-wrap;}.pdoc .annotation{color:var(--annotation);}.pdoc .inherited{margin-left:2rem;}.pdoc .inherited dt{font-weight:700;}.pdoc .inherited dt, .pdoc .inherited dd{display:inline;margin-left:0;margin-bottom:.5rem;}.pdoc .inherited dd:not(:last-child):after{content:", ";}.pdoc .inherited .class:before{content:"class ";}.pdoc .inherited .function a:after{content:"()";}.pdoc .search-result .docstring{overflow:auto;max-height:25vh;}.pdoc .search-result.focused > .attr{background-color:var(--active);}.pdoc .attribution{margin-top:2rem;display:block;opacity:0.5;transition:all 200ms;filter:grayscale(100%);}.pdoc .attribution:hover{opacity:1;filter:grayscale(0%);}.pdoc .attribution img{margin-left:5px;height:35px;vertical-align:middle;width:70px;transition:all 200ms;}</style>
</head>
<body>        <nav class="pdoc">
            <label id="navtoggle" for="togglestate" class="pdoc-button"><svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 30 30'><path stroke-linecap='round' stroke="currentColor" stroke-miterlimit='10' stroke-width='2' d='M4 7h22M4 15h22M4 23h22'/></svg></label>
            <input id="togglestate" type="checkbox">
            <div>
                        <a class="pdoc-button module-list-button" href="../analysis.html">
<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-box-arrow-in-left" viewBox="0 0 16 16">
  <path fill-rule="evenodd" d="M10 3.5a.5.5 0 0 0-.5-.5h-8a.5.5 0 0 0-.5.5v9a.5.5 0 0 0 .5.5h8a.5.5 0 0 0 .5-.5v-2a.5.5 0 0 1 1 0v2A1.5 1.5 0 0 1 9.5 14h-8A1.5 1.5 0 0 1 0 12.5v-9A1.5 1.5 0 0 1 1.5 2h8A1.5 1.5 0 0 1 11 3.5v2a.5.5 0 0 1-1 0v-2z"/>
  <path fill-rule="evenodd" d="M4.146 8.354a.5.5 0 0 1 0-.708l3-3a.5.5 0 1 1 .708.708L5.707 7.5H14.5a.5.5 0 0 1 0 1H5.707l2.147 2.146a.5.5 0 0 1-.708.708l-3-3z"/>
</svg>                            &nbsp;easyvvuq.analysis</a>

                        <input type="search" placeholder="Search..." role="searchbox" aria-label="search"
                               pattern=".+" required>




                    <h2>API Documentation</h2>
                        <ul class="memberlist">
            <li>
                    <a class="class" href="#SCAnalysisResults">SCAnalysisResults</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#SCAnalysisResults.supported_stats">supported_stats</a>
                        </li>
                        <li>
                                <a class="function" href="#SCAnalysisResults.surrogate">surrogate</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#SCAnalysis">SCAnalysis</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#SCAnalysis.__init__">SCAnalysis</a>
                        </li>
                        <li>
                                <a class="function" href="#SCAnalysis.element_name">element_name</a>
                        </li>
                        <li>
                                <a class="function" href="#SCAnalysis.element_version">element_version</a>
                        </li>
                        <li>
                                <a class="function" href="#SCAnalysis.save_state">save_state</a>
                        </li>
                        <li>
                                <a class="function" href="#SCAnalysis.load_state">load_state</a>
                        </li>
                        <li>
                                <a class="function" href="#SCAnalysis.analyse">analyse</a>
                        </li>
                        <li>
                                <a class="function" href="#SCAnalysis.compute_comb_coef">compute_comb_coef</a>
                        </li>
                        <li>
                                <a class="function" href="#SCAnalysis.adapt_dimension">adapt_dimension</a>
                        </li>
                        <li>
                                <a class="function" href="#SCAnalysis.merge_accepted_and_admissible">merge_accepted_and_admissible</a>
                        </li>
                        <li>
                                <a class="function" href="#SCAnalysis.undo_merge">undo_merge</a>
                        </li>
                        <li>
                                <a class="function" href="#SCAnalysis.get_adaptation_errors">get_adaptation_errors</a>
                        </li>
                        <li>
                                <a class="function" href="#SCAnalysis.plot_stat_convergence">plot_stat_convergence</a>
                        </li>
                        <li>
                                <a class="function" href="#SCAnalysis.surrogate">surrogate</a>
                        </li>
                        <li>
                                <a class="function" href="#SCAnalysis.quadrature">quadrature</a>
                        </li>
                        <li>
                                <a class="function" href="#SCAnalysis.combination_technique">combination_technique</a>
                        </li>
                        <li>
                                <a class="function" href="#SCAnalysis.get_moments">get_moments</a>
                        </li>
                        <li>
                                <a class="function" href="#SCAnalysis.sc_expansion">sc_expansion</a>
                        </li>
                        <li>
                                <a class="function" href="#SCAnalysis.get_sample_array">get_sample_array</a>
                        </li>
                        <li>
                                <a class="function" href="#SCAnalysis.adaptation_histogram">adaptation_histogram</a>
                        </li>
                        <li>
                                <a class="function" href="#SCAnalysis.adaptation_table">adaptation_table</a>
                        </li>
                        <li>
                                <a class="function" href="#SCAnalysis.plot_grid">plot_grid</a>
                        </li>
                        <li>
                                <a class="function" href="#SCAnalysis.SC2PCE">SC2PCE</a>
                        </li>
                        <li>
                                <a class="function" href="#SCAnalysis.get_pce_stats">get_pce_stats</a>
                        </li>
                        <li>
                                <a class="function" href="#SCAnalysis.get_pce_sobol_indices">get_pce_sobol_indices</a>
                        </li>
                        <li>
                                <a class="function" href="#SCAnalysis.compute_tensor_prod_u">compute_tensor_prod_u</a>
                        </li>
                        <li>
                                <a class="function" href="#SCAnalysis.compute_marginal">compute_marginal</a>
                        </li>
                        <li>
                                <a class="function" href="#SCAnalysis.get_sobol_indices">get_sobol_indices</a>
                        </li>
                        <li>
                                <a class="function" href="#SCAnalysis.get_uncertainty_amplification">get_uncertainty_amplification</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="function" href="#powerset">powerset</a>
            </li>
            <li>
                    <a class="function" href="#lagrange_poly">lagrange_poly</a>
            </li>
            <li>
                    <a class="function" href="#setdiff2d">setdiff2d</a>
            </li>
    </ul>


                    <a class="attribution" title="pdoc: Python API documentation generator" href="https://pdoc.dev">
                        built with <span class="visually-hidden">pdoc</span><img
                            alt="pdoc logo"
                            src="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20role%3D%22img%22%20aria-label%3D%22pdoc%20logo%22%20width%3D%22300%22%20height%3D%22150%22%20viewBox%3D%22-1%200%2060%2030%22%3E%3Ctitle%3Epdoc%3C/title%3E%3Cpath%20d%3D%22M29.621%2021.293c-.011-.273-.214-.475-.511-.481a.5.5%200%200%200-.489.503l-.044%201.393c-.097.551-.695%201.215-1.566%201.704-.577.428-1.306.486-2.193.182-1.426-.617-2.467-1.654-3.304-2.487l-.173-.172a3.43%203.43%200%200%200-.365-.306.49.49%200%200%200-.286-.196c-1.718-1.06-4.931-1.47-7.353.191l-.219.15c-1.707%201.187-3.413%202.131-4.328%201.03-.02-.027-.49-.685-.141-1.763.233-.721.546-2.408.772-4.076.042-.09.067-.187.046-.288.166-1.347.277-2.625.241-3.351%201.378-1.008%202.271-2.586%202.271-4.362%200-.976-.272-1.935-.788-2.774-.057-.094-.122-.18-.184-.268.033-.167.052-.339.052-.516%200-1.477-1.202-2.679-2.679-2.679-.791%200-1.496.352-1.987.9a6.3%206.3%200%200%200-1.001.029c-.492-.564-1.207-.929-2.012-.929-1.477%200-2.679%201.202-2.679%202.679A2.65%202.65%200%200%200%20.97%206.554c-.383.747-.595%201.572-.595%202.41%200%202.311%201.507%204.29%203.635%205.107-.037.699-.147%202.27-.423%203.294l-.137.461c-.622%202.042-2.515%208.257%201.727%2010.643%201.614.908%203.06%201.248%204.317%201.248%202.665%200%204.492-1.524%205.322-2.401%201.476-1.559%202.886-1.854%206.491.82%201.877%201.393%203.514%201.753%204.861%201.068%202.223-1.713%202.811-3.867%203.399-6.374.077-.846.056-1.469.054-1.537zm-4.835%204.313c-.054.305-.156.586-.242.629-.034-.007-.131-.022-.307-.157-.145-.111-.314-.478-.456-.908.221.121.432.25.675.355.115.039.219.051.33.081zm-2.251-1.238c-.05.33-.158.648-.252.694-.022.001-.125-.018-.307-.157-.217-.166-.488-.906-.639-1.573.358.344.754.693%201.198%201.036zm-3.887-2.337c-.006-.116-.018-.231-.041-.342.635.145%201.189.368%201.599.625.097.231.166.481.174.642-.03.049-.055.101-.067.158-.046.013-.128.026-.298.004-.278-.037-.901-.57-1.367-1.087zm-1.127-.497c.116.306.176.625.12.71-.019.014-.117.045-.345.016-.206-.027-.604-.332-.986-.695.41-.051.816-.056%201.211-.031zm-4.535%201.535c.209.22.379.47.358.598-.006.041-.088.138-.351.234-.144.055-.539-.063-.979-.259a11.66%2011.66%200%200%200%20.972-.573zm.983-.664c.359-.237.738-.418%201.126-.554.25.237.479.548.457.694-.006.042-.087.138-.351.235-.174.064-.694-.105-1.232-.375zm-3.381%201.794c-.022.145-.061.29-.149.401-.133.166-.358.248-.69.251h-.002c-.133%200-.306-.26-.45-.621.417.091.854.07%201.291-.031zm-2.066-8.077a4.78%204.78%200%200%201-.775-.584c.172-.115.505-.254.88-.378l-.105.962zm-.331%202.302a10.32%2010.32%200%200%201-.828-.502c.202-.143.576-.328.984-.49l-.156.992zm-.45%202.157l-.701-.403c.214-.115.536-.249.891-.376a11.57%2011.57%200%200%201-.19.779zm-.181%201.716c.064.398.194.702.298.893-.194-.051-.435-.162-.736-.398.061-.119.224-.3.438-.495zM8.87%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zm-.735-.389a1.15%201.15%200%200%200-.314.783%201.16%201.16%200%200%200%201.162%201.162c.457%200%20.842-.27%201.032-.653.026.117.042.238.042.362a1.68%201.68%200%200%201-1.679%201.679%201.68%201.68%200%200%201-1.679-1.679c0-.843.626-1.535%201.436-1.654zM5.059%205.406A1.68%201.68%200%200%201%203.38%207.085a1.68%201.68%200%200%201-1.679-1.679c0-.037.009-.072.011-.109.21.3.541.508.935.508a1.16%201.16%200%200%200%201.162-1.162%201.14%201.14%200%200%200-.474-.912c.015%200%20.03-.005.045-.005.926.001%201.679.754%201.679%201.68zM3.198%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zM1.375%208.964c0-.52.103-1.035.288-1.52.466.394%201.06.64%201.717.64%201.144%200%202.116-.725%202.499-1.738.383%201.012%201.355%201.738%202.499%201.738.867%200%201.631-.421%202.121-1.062.307.605.478%201.267.478%201.942%200%202.486-2.153%204.51-4.801%204.51s-4.801-2.023-4.801-4.51zm24.342%2019.349c-.985.498-2.267.168-3.813-.979-3.073-2.281-5.453-3.199-7.813-.705-1.315%201.391-4.163%203.365-8.423.97-3.174-1.786-2.239-6.266-1.261-9.479l.146-.492c.276-1.02.395-2.457.444-3.268a6.11%206.11%200%200%200%201.18.115%206.01%206.01%200%200%200%202.536-.562l-.006.175c-.802.215-1.848.612-2.021%201.25-.079.295.021.601.274.837.219.203.415.364.598.501-.667.304-1.243.698-1.311%201.179-.02.144-.022.507.393.787.213.144.395.26.564.365-1.285.521-1.361.96-1.381%201.126-.018.142-.011.496.427.746l.854.489c-.473.389-.971.914-.999%201.429-.018.278.095.532.316.713.675.556%201.231.721%201.653.721.059%200%20.104-.014.158-.02.207.707.641%201.64%201.513%201.64h.013c.8-.008%201.236-.345%201.462-.626.173-.216.268-.457.325-.692.424.195.93.374%201.372.374.151%200%20.294-.021.423-.068.732-.27.944-.704.993-1.021.009-.061.003-.119.002-.179.266.086.538.147.789.147.15%200%20.294-.021.423-.069.542-.2.797-.489.914-.754.237.147.478.258.704.288.106.014.205.021.296.021.356%200%20.595-.101.767-.229.438.435%201.094.992%201.656%201.067.106.014.205.021.296.021a1.56%201.56%200%200%200%20.323-.035c.17.575.453%201.289.866%201.605.358.273.665.362.914.362a.99.99%200%200%200%20.421-.093%201.03%201.03%200%200%200%20.245-.164c.168.428.39.846.68%201.068.358.273.665.362.913.362a.99.99%200%200%200%20.421-.093c.317-.148.512-.448.639-.762.251.157.495.257.726.257.127%200%20.25-.024.37-.071.427-.17.706-.617.841-1.314.022-.015.047-.022.068-.038.067-.051.133-.104.196-.159-.443%201.486-1.107%202.761-2.086%203.257zM8.66%209.925a.5.5%200%201%200-1%200c0%20.653-.818%201.205-1.787%201.205s-1.787-.552-1.787-1.205a.5.5%200%201%200-1%200c0%201.216%201.25%202.205%202.787%202.205s2.787-.989%202.787-2.205zm4.4%2015.965l-.208.097c-2.661%201.258-4.708%201.436-6.086.527-1.542-1.017-1.88-3.19-1.844-4.198a.4.4%200%200%200-.385-.414c-.242-.029-.406.164-.414.385-.046%201.249.367%203.686%202.202%204.896.708.467%201.547.7%202.51.7%201.248%200%202.706-.392%204.362-1.174l.185-.086a.4.4%200%200%200%20.205-.527c-.089-.204-.326-.291-.527-.206zM9.547%202.292c.093.077.205.114.317.114a.5.5%200%200%200%20.318-.886L8.817.397a.5.5%200%200%200-.703.068.5.5%200%200%200%20.069.703l1.364%201.124zm-7.661-.065c.086%200%20.173-.022.253-.068l1.523-.893a.5.5%200%200%200-.506-.863l-1.523.892a.5.5%200%200%200-.179.685c.094.158.261.247.432.247z%22%20transform%3D%22matrix%28-1%200%200%201%2058%200%29%22%20fill%3D%22%233bb300%22/%3E%3Cpath%20d%3D%22M.3%2021.86V10.18q0-.46.02-.68.04-.22.18-.5.28-.54%201.34-.54%201.06%200%201.42.28.38.26.44.78.76-1.04%202.38-1.04%201.64%200%203.1%201.54%201.46%201.54%201.46%203.58%200%202.04-1.46%203.58-1.44%201.54-3.08%201.54-1.64%200-2.38-.92v4.04q0%20.46-.04.68-.02.22-.18.5-.14.3-.5.42-.36.12-.98.12-.62%200-1-.12-.36-.12-.52-.4-.14-.28-.18-.5-.02-.22-.02-.68zm3.96-9.42q-.46.54-.46%201.18%200%20.64.46%201.18.48.52%201.2.52.74%200%201.24-.52.52-.52.52-1.18%200-.66-.48-1.18-.48-.54-1.26-.54-.76%200-1.22.54zm14.741-8.36q.16-.3.54-.42.38-.12%201-.12.64%200%201.02.12.38.12.52.42.16.3.18.54.04.22.04.68v11.94q0%20.46-.04.7-.02.22-.18.5-.3.54-1.7.54-1.38%200-1.54-.98-.84.96-2.34.96-1.8%200-3.28-1.56-1.48-1.58-1.48-3.66%200-2.1%201.48-3.68%201.5-1.58%203.28-1.58%201.48%200%202.3%201v-4.2q0-.46.02-.68.04-.24.18-.52zm-3.24%2010.86q.52.54%201.26.54.74%200%201.22-.54.5-.54.5-1.18%200-.66-.48-1.22-.46-.56-1.26-.56-.8%200-1.28.56-.48.54-.48%201.2%200%20.66.52%201.2zm7.833-1.2q0-2.4%201.68-3.96%201.68-1.56%203.84-1.56%202.16%200%203.82%201.56%201.66%201.54%201.66%203.94%200%201.66-.86%202.96-.86%201.28-2.1%201.9-1.22.6-2.54.6-1.32%200-2.56-.64-1.24-.66-2.1-1.92-.84-1.28-.84-2.88zm4.18%201.44q.64.48%201.3.48.66%200%201.32-.5.66-.5.66-1.48%200-.98-.62-1.46-.62-.48-1.34-.48-.72%200-1.34.5-.62.5-.62%201.48%200%20.96.64%201.46zm11.412-1.44q0%20.84.56%201.32.56.46%201.18.46.64%200%201.18-.36.56-.38.9-.38.6%200%201.46%201.06.46.58.46%201.04%200%20.76-1.1%201.42-1.14.8-2.8.8-1.86%200-3.58-1.34-.82-.64-1.34-1.7-.52-1.08-.52-2.36%200-1.3.52-2.34.52-1.06%201.34-1.7%201.66-1.32%203.54-1.32.76%200%201.48.22.72.2%201.06.4l.32.2q.36.24.56.38.52.4.52.92%200%20.5-.42%201.14-.72%201.1-1.38%201.1-.38%200-1.08-.44-.36-.34-1.04-.34-.66%200-1.24.48-.58.48-.58%201.34z%22%20fill%3D%22green%22/%3E%3C/svg%3E"/>
                    </a>
            </div>
        </nav>
    <main class="pdoc">
            <section>
                    <h1 class="modulename">
<a href="./../../easyvvuq.html">easyvvuq</a><wbr>.<a href="./../analysis.html">analysis</a><wbr>.sc_analysis    </h1>

                        <div class="docstring"><p>ANALYSIS CLASS FOR THE SC SAMPLER</p>
</div>

                        <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">ANALYSIS CLASS FOR THE SC SAMPLER</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">chaospy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">product</span><span class="p">,</span> <span class="n">chain</span><span class="p">,</span> <span class="n">combinations</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">easyvvuq</span> <span class="kn">import</span> <span class="n">OutputType</span>
<span class="kn">from</span> <span class="nn">.base</span> <span class="kn">import</span> <span class="n">BaseAnalysisElement</span>
<span class="kn">from</span> <span class="nn">.results</span> <span class="kn">import</span> <span class="n">AnalysisResults</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="c1"># from scipy.special import comb</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s2">&quot;Wouter Edeling&quot;</span>
<span class="n">__copyright__</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>

<span class="s2">    Copyright 2018 Robin A. Richardson, David W. Wright</span>

<span class="s2">    This file is part of EasyVVUQ</span>

<span class="s2">    EasyVVUQ is free software: you can redistribute it and/or modify</span>
<span class="s2">    it under the terms of the Lesser GNU General Public License as published by</span>
<span class="s2">    the Free Software Foundation, either version 3 of the License, or</span>
<span class="s2">    (at your option) any later version.</span>

<span class="s2">    EasyVVUQ is distributed in the hope that it will be useful,</span>
<span class="s2">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="s2">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="s2">    Lesser GNU General Public License for more details.</span>

<span class="s2">    You should have received a copy of the Lesser GNU General Public License</span>
<span class="s2">    along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.</span>

<span class="s2">&quot;&quot;&quot;</span>
<span class="n">__license__</span> <span class="o">=</span> <span class="s2">&quot;LGPL&quot;</span>


<span class="k">class</span> <span class="nc">SCAnalysisResults</span><span class="p">(</span><span class="n">AnalysisResults</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">_get_sobols_first</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qoi</span><span class="p">,</span> <span class="n">input_</span><span class="p">):</span>
        <span class="n">raw_dict</span> <span class="o">=</span> <span class="n">AnalysisResults</span><span class="o">.</span><span class="n">_keys_to_tuples</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="p">[</span><span class="s1">&#39;sobols_first&#39;</span><span class="p">])</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">raw_dict</span><span class="p">[</span><span class="n">AnalysisResults</span><span class="o">.</span><span class="n">_to_tuple</span><span class="p">(</span><span class="n">qoi</span><span class="p">)][</span><span class="n">input_</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">result</span><span class="p">)])</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">supported_stats</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Types of statistics supported by the describe method.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="s1">&#39;var&#39;</span><span class="p">,</span> <span class="s1">&#39;std&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_describe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qoi</span><span class="p">,</span> <span class="n">statistic</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">statistic</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">supported_stats</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="p">[</span><span class="s1">&#39;statistical_moments&#39;</span><span class="p">][</span><span class="n">qoi</span><span class="p">][</span><span class="n">statistic</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">surrogate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an SC surrogate model.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        A function that takes a dictionary of parameter - value pairs and returns</span>
<span class="sd">        a dictionary with the results (same output as decoder).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">surrogate_fn</span><span class="p">(</span><span class="n">inputs</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">swap</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">inputs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">]))</span><span class="o">.</span><span class="n">T</span>
            <span class="n">results</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">qoi</span><span class="p">,</span> <span class="n">swap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surrogate_</span><span class="p">(</span><span class="n">qoi</span><span class="p">,</span> <span class="n">values</span><span class="p">)))</span> <span class="k">for</span> <span class="n">qoi</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">qois</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">results</span>
        <span class="k">return</span> <span class="n">surrogate_fn</span>


<span class="k">class</span> <span class="nc">SCAnalysis</span><span class="p">(</span><span class="n">BaseAnalysisElement</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sampler</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">qoi_cols</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sampler : SCSampler</span>
<span class="sd">            Sampler used to initiate the SC analysis</span>
<span class="sd">        qoi_cols : list or None</span>
<span class="sd">            Column names for quantities of interest (for which analysis is</span>
<span class="sd">            performed).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">sampler</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;SC analysis requires a paired sampler to be passed&#39;</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">qoi_cols</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Analysis element requires a list of &quot;</span>
                               <span class="s2">&quot;quantities of interest (qoi)&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">qoi_cols</span> <span class="o">=</span> <span class="n">qoi_cols</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_type</span> <span class="o">=</span> <span class="n">OutputType</span><span class="o">.</span><span class="n">SUMMARY</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span> <span class="o">=</span> <span class="n">sampler</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimension_adaptive</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">dimension_adaptive</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension_adaptive</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">adaptation_errors</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mean_history</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">std_history</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sparse</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">sparse</span>

    <span class="k">def</span> <span class="nf">element_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Name for this element for logging purposes&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;SC_Analysis&quot;</span>

    <span class="k">def</span> <span class="nf">element_version</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Version of this element for logging purposes&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;0.5&quot;</span>

    <span class="k">def</span> <span class="nf">save_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Saves the complete state of the analysis object to a pickle file,</span>
<span class="sd">        except the sampler object (self.samples).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename : string</span>
<span class="sd">            name to the file to write the state to</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Saving analysis state to </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">filename</span><span class="p">)</span>
        <span class="c1"># make a copy of the state, and do not store the sampler as well</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;sampler&#39;</span><span class="p">]</span>
        <span class="n">file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span>
        <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span>
        <span class="n">file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">load_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Loads the complete state of the analysis object from a</span>
<span class="sd">        pickle file, stored using save_state.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename : string</span>
<span class="sd">            name of the file to load</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Loading analysis state from </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">filename</span><span class="p">)</span>
        <span class="n">file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">state</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="n">file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">analyse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_frame</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">compute_moments</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">compute_Sobols</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform SC analysis on input `data_frame`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data_frame : pandas.DataFrame</span>
<span class="sd">            Input data for analysis.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Results dictionary with sub-dicts with keys:</span>
<span class="sd">            [&#39;statistical_moments&#39;, &#39;sobol_indices&#39;].</span>
<span class="sd">            Each dict has an entry for each item in `qoi_cols`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">data_frame</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Analysis element needs a data frame to &quot;</span>
                               <span class="s2">&quot;analyse&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_frame</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="ow">and</span> <span class="n">data_frame</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;No data in data frame passed to analyse element&quot;</span><span class="p">)</span>

        <span class="c1"># the number of uncertain parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">N</span>
        <span class="c1"># tensor grid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xi_d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">xi_d</span>
        <span class="c1"># the maximum level (quad order) of the (sparse) grid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">L</span>

        <span class="c1"># if L &lt; L_min: quadratures and interpolations are zero</span>
        <span class="c1"># For full tensor grid: there is only one level: L_min = L</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">L_min</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">polynomial_order</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">l_norm_min</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span>
        <span class="c1"># For sparse grid: one or more levels</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">L_min</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="c1"># multi indices (stored in l_norm) for isotropic sparse grid or</span>
            <span class="c1"># dimension-adaptive grid before the 1st refinement.</span>
            <span class="c1"># If dimension_adaptive and nadaptations &gt; 0: l_norm</span>
            <span class="c1"># is computed in self.adaptation_metric</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension_adaptive</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">nadaptations</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># the maximum level (quad order) of the (sparse) grid</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">compute_sparse_multi_idx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">l_norm_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="c1"># #compute generalized combination coefficients</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comb_coef</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_comb_coef</span><span class="p">()</span>

        <span class="c1"># 1d weights and points per level</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xi_1d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">xi_1d</span>
        <span class="c1"># self.wi_1d = self.compute_SC_weights(rule=self.sampler.quad_rule)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wi_1d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">wi_1d</span>

        <span class="c1"># Extract output values for each quantity of interest from Dataframe</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Loading samples...&#39;</span><span class="p">)</span>
        <span class="n">qoi_cols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qoi_cols</span>
        <span class="n">samples</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">qoi_cols</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">run_id</span> <span class="ow">in</span> <span class="n">data_frame</span><span class="p">[(</span><span class="s1">&#39;run_id&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span><span class="o">.</span><span class="n">unique</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">qoi_cols</span><span class="p">:</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">data_frame</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">data_frame</span><span class="p">[(</span><span class="s1">&#39;run_id&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">==</span> <span class="n">run_id</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
                <span class="n">samples</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">samples</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;done&#39;</span><span class="p">)</span>

        <span class="c1"># size of one code sample</span>
        <span class="c1"># TODO: change this to include QoI of different size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N_qoi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">qoi_cols</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span>

        <span class="c1"># assume that self.l_norm has changed, and that the interpolation</span>
        <span class="c1"># must be initialised, see sc_expansion subroutine</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_interpolation</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># TODO: same pce coefs must be computed for every qoi</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pce_coefs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SC2PCE</span><span class="p">(</span><span class="n">samples</span><span class="p">[</span><span class="n">qoi_cols</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>

        <span class="c1"># Compute descriptive statistics for each quantity of interest</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;statistical_moments&#39;</span><span class="p">:</span> <span class="p">{},</span>
                   <span class="s1">&#39;sobols_first&#39;</span><span class="p">:</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="p">{}</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">qoi_cols</span><span class="p">},</span>
                   <span class="s1">&#39;sobols&#39;</span><span class="p">:</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="p">{}</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">qoi_cols</span><span class="p">}}</span>

        <span class="k">if</span> <span class="n">compute_moments</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">qoi_k</span> <span class="ow">in</span> <span class="n">qoi_cols</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse</span><span class="p">:</span>
                    <span class="n">mean_k</span><span class="p">,</span> <span class="n">var_k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_moments</span><span class="p">(</span><span class="n">qoi_k</span><span class="p">)</span>
                    <span class="n">std_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">var_k</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">pce_coefs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SC2PCE</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">qoi_k</span><span class="p">])</span>
                    <span class="n">mean_k</span><span class="p">,</span> <span class="n">var_k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pce_stats</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span><span class="p">,</span> <span class="n">pce_coefs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comb_coef</span><span class="p">)</span>
                    <span class="n">std_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">var_k</span><span class="p">)</span>

                <span class="c1"># compute statistical moments</span>
                <span class="n">results</span><span class="p">[</span><span class="s1">&#39;statistical_moments&#39;</span><span class="p">][</span><span class="n">qoi_k</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;mean&#39;</span><span class="p">:</span> <span class="n">mean_k</span><span class="p">,</span>
                                                         <span class="s1">&#39;var&#39;</span><span class="p">:</span> <span class="n">var_k</span><span class="p">,</span>
                                                         <span class="s1">&#39;std&#39;</span><span class="p">:</span> <span class="n">std_k</span><span class="p">}</span>

        <span class="k">if</span> <span class="n">compute_Sobols</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">qoi_k</span> <span class="ow">in</span> <span class="n">qoi_cols</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse</span><span class="p">:</span>
                    <span class="n">results</span><span class="p">[</span><span class="s1">&#39;sobols&#39;</span><span class="p">][</span><span class="n">qoi_k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sobol_indices</span><span class="p">(</span><span class="n">qoi_k</span><span class="p">,</span> <span class="s1">&#39;first_order&#39;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;sobols&#39;</span><span class="p">][</span><span class="n">qoi_k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pce_sobol_indices</span><span class="p">(</span>
                        <span class="n">qoi_k</span><span class="p">,</span> <span class="s1">&#39;first_order&#39;</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">param_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">vary</span><span class="o">.</span><span class="n">get_keys</span><span class="p">()):</span>
                    <span class="n">results</span><span class="p">[</span><span class="s1">&#39;sobols_first&#39;</span><span class="p">][</span><span class="n">qoi_k</span><span class="p">][</span><span class="n">param_name</span><span class="p">]</span> <span class="o">=</span> \
                        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;sobols&#39;</span><span class="p">][</span><span class="n">qoi_k</span><span class="p">][(</span><span class="n">idx</span><span class="p">,)]</span>

        <span class="n">results</span> <span class="o">=</span> <span class="n">SCAnalysisResults</span><span class="p">(</span><span class="n">raw_data</span><span class="o">=</span><span class="n">results</span><span class="p">,</span> <span class="n">samples</span><span class="o">=</span><span class="n">data_frame</span><span class="p">,</span>
                                    <span class="n">qois</span><span class="o">=</span><span class="n">qoi_cols</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">vary</span><span class="o">.</span><span class="n">get_keys</span><span class="p">()))</span>
        <span class="n">results</span><span class="o">.</span><span class="n">surrogate_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surrogate</span>
        <span class="k">return</span> <span class="n">results</span>

    <span class="k">def</span> <span class="nf">compute_comb_coef</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute general combination coefficients. These are the coefficients</span>
<span class="sd">        multiplying the tensor products associated to each multi index l,</span>
<span class="sd">        see page 12 Gerstner &amp; Griebel, numerical integration using sparse grids</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s1">&#39;l_norm&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">l_norm</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;l_norm&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">l_norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span>

        <span class="n">comb_coef</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Computing combination coefficients...&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">l_norm</span><span class="p">:</span>
            <span class="n">coef</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="c1"># for every k, subtract all multi indices</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">l_norm</span><span class="p">:</span>
                <span class="n">z</span> <span class="o">=</span> <span class="n">l</span> <span class="o">-</span> <span class="n">k</span>
                <span class="c1"># if the results contains only 0&#39;s and 1&#39;s, then z is the</span>
                <span class="c1"># vector that can be formed from a tensor product of unit vectors</span>
                <span class="c1"># for which k+z is in self.l_norm</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">z</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)):</span>
                    <span class="n">coef</span> <span class="o">+=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">z</span><span class="p">))</span>
            <span class="n">comb_coef</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span> <span class="o">=</span> <span class="n">coef</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;done&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">comb_coef</span>

    <span class="k">def</span> <span class="nf">adapt_dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qoi</span><span class="p">,</span> <span class="n">data_frame</span><span class="p">,</span> <span class="n">store_stats_history</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">method</span><span class="o">=</span><span class="s1">&#39;surplus&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the adaptation metric and decide which of the admissible</span>
<span class="sd">        level indices to include in next iteration of the sparse grid. The</span>
<span class="sd">        adaptation metric is based on the hierarchical surplus, defined as the</span>
<span class="sd">        difference between the new code values of the admissible level indices,</span>
<span class="sd">        and the SC surrogate of the previous iteration. Alternatively, it can be</span>
<span class="sd">        based on the difference between the output mean of the current level,</span>
<span class="sd">        and the mean computed with one extra admissible index.</span>

<span class="sd">        This subroutine must be called AFTER the code is evaluated at</span>
<span class="sd">        the new points, but BEFORE the analysis is performed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        qoi : string</span>
<span class="sd">            the name of the quantity of interest which is used</span>
<span class="sd">            to base the adaptation metric on.</span>
<span class="sd">        data_frame : pandas.DataFrame</span>
<span class="sd">        store_stats_history : bool</span>
<span class="sd">            store the mean and variance at each refinement in self.mean_history</span>
<span class="sd">            and self.std_history. Used for checking convergence in the statistics</span>
<span class="sd">            over the refinement iterations</span>
<span class="sd">        method : string</span>
<span class="sd">            name of the refinement error, default is &#39;surplus&#39;. In this case the</span>
<span class="sd">            error is based on the hierarchical surplus, which is an interpolation</span>
<span class="sd">            based error. Another possibility is &#39;var&#39;,</span>
<span class="sd">            in which case the error is based on the difference in the </span>
<span class="sd">            variance between the current estimate and the estimate obtained</span>
<span class="sd">            when a particular candidate direction is added.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Refining sampling plan...&#39;</span><span class="p">)</span>
        <span class="c1"># load the code samples</span>
        <span class="n">samples</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_frame</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">run_id</span> <span class="ow">in</span> <span class="n">data_frame</span><span class="p">[(</span><span class="s1">&#39;run_id&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span><span class="o">.</span><span class="n">unique</span><span class="p">():</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">data_frame</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">data_frame</span><span class="p">[(</span><span class="s1">&#39;run_id&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">==</span> <span class="n">run_id</span><span class="p">][</span><span class="n">qoi</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
                <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;var&#39;</span><span class="p">:</span>
            <span class="n">all_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">admissible_idx</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xi_1d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">xi_1d</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wi_1d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">wi_1d</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pce_coefs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SC2PCE</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">l_norm</span><span class="o">=</span><span class="n">all_idx</span><span class="p">,</span>
                                         <span class="n">xi_d</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">xi_d</span><span class="p">)</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">var_l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pce_stats</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pce_coefs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comb_coef</span><span class="p">)</span>

        <span class="c1"># the currently accepted grid points</span>
        <span class="n">xi_d_accepted</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">generate_grid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span><span class="p">)</span>

        <span class="c1"># compute the hierarchical surplus based error for every admissible l</span>
        <span class="n">error</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">admissible_idx</span><span class="p">:</span>
            <span class="n">error</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># compute the error based on the hierarchical surplus (interpolation based)</span>
            <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;surplus&#39;</span><span class="p">:</span>
                <span class="c1"># collocation points of current level index l</span>
                <span class="n">X_l</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">xi_1d</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">l</span><span class="p">[</span><span class="n">n</span><span class="p">]]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)]</span>
                <span class="n">X_l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">X_l</span><span class="p">)))</span>
                <span class="c1"># only consider new points, subtract the accepted points</span>
                <span class="n">X_l</span> <span class="o">=</span> <span class="n">setdiff2d</span><span class="p">(</span><span class="n">X_l</span><span class="p">,</span> <span class="n">xi_d_accepted</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="n">X_l</span><span class="p">:</span>
                    <span class="c1"># find the location of the current xi in the global grid</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">xi</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">xi_d</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="c1"># hierarchical surplus error at xi</span>
                    <span class="n">hier_surplus</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">surrogate</span><span class="p">(</span><span class="n">qoi</span><span class="p">,</span> <span class="n">xi</span><span class="p">)</span>
                    <span class="k">if</span> <span class="s1">&#39;index&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                        <span class="n">hier_surplus</span> <span class="o">=</span> <span class="n">hier_surplus</span><span class="p">[</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">]]</span>
                        <span class="n">error</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">hier_surplus</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">error</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">hier_surplus</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">))</span>
                <span class="c1"># compute mean error over all points in X_l</span>
                <span class="n">error</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">error</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)])</span>
            <span class="c1"># compute the error based on quadrature of the variance</span>
            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;var&#39;</span><span class="p">:</span>
                <span class="c1"># create a candidate set of multi indices by adding the current</span>
                <span class="c1"># admissible index to l_norm</span>
                <span class="n">candidate_l_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span><span class="p">,</span> <span class="n">l</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">])))</span>
                <span class="c1"># now we must recompute the combination coefficients</span>
                <span class="n">c_l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_comb_coef</span><span class="p">(</span><span class="n">l_norm</span><span class="o">=</span><span class="n">candidate_l_norm</span><span class="p">)</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">var_candidate_l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pce_stats</span><span class="p">(</span><span class="n">candidate_l_norm</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pce_coefs</span><span class="p">,</span> <span class="n">c_l</span><span class="p">)</span>
                <span class="c1">#error in var</span>
                <span class="n">error</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">var_candidate_l</span> <span class="o">-</span> <span class="n">var_l</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Specified refinement method </span><span class="si">%s</span><span class="s1"> not recognized&#39;</span> <span class="o">%</span> <span class="n">method</span><span class="p">)</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Accepted are surplus, mean or var&#39;</span><span class="p">)</span>
                <span class="kn">import</span> <span class="nn">sys</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">error</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="c1"># logging.debug(&quot;Surplus error when l = %s is %s&quot; % (key, error[key]))</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Refinement error for l = </span><span class="si">%s</span><span class="s2"> is </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">error</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span>
        <span class="c1"># find the admissble index with the largest error</span>
        <span class="n">l_star</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">error</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">error</span><span class="o">.</span><span class="n">get</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">])</span>
        <span class="c1"># logging.debug(&#39;Selecting %s for refinement.&#39; % l_star)</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Selecting </span><span class="si">%s</span><span class="s1"> for refinement.&#39;</span> <span class="o">%</span> <span class="n">l_star</span><span class="p">)</span>
        <span class="c1"># add max error to list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adaptation_errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">error</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>

        <span class="c1"># add l_star to the current accepted level indices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span><span class="p">,</span> <span class="n">l_star</span><span class="p">))</span>
        <span class="c1"># if someone executes this function twice for some reason,</span>
        <span class="c1"># remove the duplicate l_star entry. Keep order unaltered</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">idx</span><span class="p">)])</span>

        <span class="c1"># peform the analyse step, but do not compute moments and Sobols</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analyse</span><span class="p">(</span><span class="n">data_frame</span><span class="p">,</span> <span class="n">compute_moments</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">compute_Sobols</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># if True store the mean and variance at eacht iteration of the adaptive</span>
        <span class="c1"># algorithmn</span>
        <span class="k">if</span> <span class="n">store_stats_history</span><span class="p">:</span>
            <span class="c1"># mean_f, var_f = self.get_moments(qoi)</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Storing moments of iteration </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">nadaptations</span><span class="p">)</span>
            <span class="n">pce_coefs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SC2PCE</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">mean_f</span><span class="p">,</span> <span class="n">var_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pce_stats</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span><span class="p">,</span> <span class="n">pce_coefs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comb_coef</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mean_history</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mean_f</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">std_history</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var_f</span><span class="p">)</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;done&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">merge_accepted_and_admissible</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;In the case of the dimension-adaptive sampler, there are 2 sets of</span>
<span class="sd">        quadrature multi indices. There are the accepted indices that are actually</span>
<span class="sd">        used in the analysis, and the admissible indices, of which some might</span>
<span class="sd">        move to the accepted set in subsequent iterations. This subroutine merges</span>
<span class="sd">        the two sets of multi indices by moving all admissible to the set of</span>
<span class="sd">        accepted indices.</span>
<span class="sd">        Do this at the end, when no more refinements will be executed. The</span>
<span class="sd">        samples related to the admissble indices are already computed, although</span>
<span class="sd">        not used in the analysis. By executing this subroutine at very end, all</span>
<span class="sd">        computed samples are used during the final postprocessing stage. Execute</span>
<span class="sd">        campaign.apply_analysis to let the new set of indices take effect.</span>
<span class="sd">        If further refinements are executed after all via sampler.look_ahead, the</span>
<span class="sd">        number of new admissible samples to be computed can be very high,</span>
<span class="sd">        especially in high dimensions. It is possible to undo the merge via</span>
<span class="sd">        analysis.undo_merge before new refinements are made. Execute</span>
<span class="sd">        campaign.apply_analysis again to let the old set of indices take effect.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s1">&#39;include&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">include</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;include&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">include</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">dimension_adaptive</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Moving admissible indices to the accepted set...&#39;</span><span class="p">)</span>
            <span class="c1"># make a backup of l_norm, such that undo_merge can revert back</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">l_norm_backup</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span><span class="p">)</span>
            <span class="c1"># merge admissible and accepted multi indices</span>
            <span class="k">if</span> <span class="n">level</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">merged_l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">admissible_idx</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">admissible_idx</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">admissible_idx</span><span class="p">:</span>
                    <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">l</span> <span class="o">==</span> <span class="n">L</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">L</span> <span class="o">&lt;=</span> <span class="n">level</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">include</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="n">admissible_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
                        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">admissible_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">admissible_idx</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">count</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">])</span>
                <span class="n">merged_l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span><span class="p">,</span> <span class="n">admissible_idx</span><span class="p">))</span>
            <span class="c1"># make sure final result contains only unique indices and store</span>
            <span class="c1">#results in l_norm</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">merged_l</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># return np.array([merged_l[i] for i in sorted(idx)])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">merged_l</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">idx</span><span class="p">)])</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;done&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">undo_merge</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This reverses the effect of the merge_accepted_and_admissble subroutine.</span>
<span class="sd">        Execute if further refinement are required after all.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">dimension_adaptive</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">l_norm_backup</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Restored old multi indices.&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_adaptation_errors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns self.adaptation_errors</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">adaptation_errors</span>

    <span class="k">def</span> <span class="nf">plot_stat_convergence</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plots the convergence of the statistical mean and std dev over the different</span>
<span class="sd">        refinements in a dimension-adaptive setting. Specifically the inf norm</span>
<span class="sd">        of the difference between the stats of iteration i and iteration i-1</span>
<span class="sd">        is plotted.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension_adaptive</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Only works for the dimension adaptive sampler.&#39;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="n">K</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mean_history</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">K</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Means from at least two refinements are required&#39;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">differ_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">K</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">differ_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">K</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">K</span><span class="p">):</span>
                <span class="n">differ_mean</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mean_history</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span>
                                                    <span class="bp">self</span><span class="o">.</span><span class="n">mean_history</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
                <span class="c1"># make relative</span>
                <span class="n">differ_mean</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">differ_mean</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mean_history</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span>
                                                                         <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>

                <span class="n">differ_std</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">std_history</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span>
                                                   <span class="bp">self</span><span class="o">.</span><span class="n">std_history</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
                <span class="c1"># make relative</span>
                <span class="n">differ_std</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">differ_std</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">std_history</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span>
                                                                       <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>

        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="s1">&#39;stat_conv&#39;</span><span class="p">)</span>
        <span class="n">ax1</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;moment convergence&#39;</span><span class="p">)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;iteration&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
        <span class="c1"># ax1.set_ylabel(r&#39;$ ||\mathrm{mean}_i - \mathrm{mean}_{i - 1}||_\infty$&#39;,</span>
        <span class="c1"># color=&#39;r&#39;, fontsize=12)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;relative error mean&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">K</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">differ_mean</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;+&#39;</span><span class="p">)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">labelcolor</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>

        <span class="n">ax2</span> <span class="o">=</span> <span class="n">ax1</span><span class="o">.</span><span class="n">twinx</span><span class="p">()</span>  <span class="c1"># instantiate a second axes that shares the same x-axis</span>

        <span class="c1"># ax2.set_ylabel(r&#39;$ ||\mathrm{var}_i - \mathrm{var}_{i - 1}||_\infty$&#39;,</span>
        <span class="c1"># color=&#39;b&#39;, fontsize=12)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;relative error variance&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">K</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">differ_std</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;*&#39;</span><span class="p">)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">labelcolor</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">surrogate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qoi</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">L</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Use sc_expansion UQP as a surrogate</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        qoi : str</span>
<span class="sd">            name of the qoi</span>
<span class="sd">        x : array</span>
<span class="sd">            location at which to evaluate the surrogate</span>
<span class="sd">        L : int</span>
<span class="sd">            level of the (sparse) grid, default = self.L</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        the interpolated value of qoi at x (float, (N_qoi,))</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc_expansion</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">qoi</span><span class="p">],</span> <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">quadrature</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qoi</span><span class="p">,</span> <span class="n">samples</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes a (Smolyak) quadrature</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        qoi : str</span>
<span class="sd">            name of the qoi</span>

<span class="sd">        samples: array</span>
<span class="sd">            compute the mean by setting samples = self.samples.</span>
<span class="sd">            To compute the variance, set samples = (self.samples - mean)**2</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        the quadrature of qoi</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">samples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">qoi</span><span class="p">]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">combination_technique</span><span class="p">(</span><span class="n">qoi</span><span class="p">,</span> <span class="n">samples</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">combination_technique</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qoi</span><span class="p">,</span> <span class="n">samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Efficient quadrature formulation for (sparse) grids. See:</span>

<span class="sd">            Gerstner, Griebel, &quot;Numerical integration using sparse grids&quot;</span>
<span class="sd">            Uses the general combination technique (page 12).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        qoi : str</span>
<span class="sd">            name of the qoi</span>

<span class="sd">        samples : array</span>
<span class="sd">            compute the mean by setting samples = self.samples.</span>
<span class="sd">            To compute the variance, set samples = (self.samples - mean)**2</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">samples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">qoi</span><span class="p">]</span>

        <span class="c1"># In the case of quadrature-based refinement, we need to specify</span>
        <span class="c1"># l_norm, comb_coef and xi_d other than the current defualt values</span>
        <span class="k">if</span> <span class="s1">&#39;l_norm&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">l_norm</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;l_norm&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">l_norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span>

        <span class="k">if</span> <span class="s1">&#39;comb_coef&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">comb_coef</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;comb_coef&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">comb_coef</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comb_coef</span>

        <span class="k">if</span> <span class="s1">&#39;xi_d&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">xi_d</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;xi_d&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xi_d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi_d</span>

        <span class="c1"># quadrature Q</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="c1"># loop over l</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">l_norm</span><span class="p">:</span>
            <span class="c1"># compute the tensor product of parameter and weight values</span>
            <span class="n">X_k</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">xi_1d</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">l</span><span class="p">[</span><span class="n">n</span><span class="p">]]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)]</span>
            <span class="n">W_k</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">wi_1d</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">l</span><span class="p">[</span><span class="n">n</span><span class="p">]]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)]</span>

            <span class="n">X_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">X_k</span><span class="p">)))</span>
            <span class="n">W_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">W_k</span><span class="p">)))</span>
            <span class="n">W_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">W_k</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">W_k</span> <span class="o">=</span> <span class="n">W_k</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">W_k</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">])</span>

            <span class="c1"># scaling factor of combination technique</span>
            <span class="n">W_k</span> <span class="o">=</span> <span class="n">W_k</span> <span class="o">*</span> <span class="n">comb_coef</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span>

            <span class="c1"># find corresponding code values</span>
            <span class="n">f_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">samples</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">x</span> <span class="o">==</span> <span class="n">xi_d</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">X_k</span><span class="p">])</span>

            <span class="c1"># quadrature of Q^1_{k1} X ... X Q^1_{kN} product</span>
            <span class="n">Q</span> <span class="o">=</span> <span class="n">Q</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">f_k</span> <span class="o">*</span> <span class="n">W_k</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="k">return</span> <span class="n">Q</span>

    <span class="k">def</span> <span class="nf">get_moments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qoi</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        qoi : str</span>
<span class="sd">            name of the qoi</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mean and variance of qoi (float (N_qoi,))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Computing moments...&#39;</span><span class="p">)</span>
        <span class="c1"># compute mean</span>
        <span class="n">mean_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">quadrature</span><span class="p">(</span><span class="n">qoi</span><span class="p">)</span>
        <span class="c1"># compute variance</span>
        <span class="n">variance_samples</span> <span class="o">=</span> <span class="p">[(</span><span class="n">sample</span> <span class="o">-</span> <span class="n">mean_f</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">sample</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">qoi</span><span class="p">]]</span>
        <span class="n">var_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">quadrature</span><span class="p">(</span><span class="n">qoi</span><span class="p">,</span> <span class="n">samples</span><span class="o">=</span><span class="n">variance_samples</span><span class="p">)</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;done&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mean_f</span><span class="p">,</span> <span class="n">var_f</span>

    <span class="k">def</span> <span class="nf">sc_expansion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">samples</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Non recursive implementation of the SC expansion. Performs interpolation</span>
<span class="sd">        of code output samples for both full and sparse grids.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        samples : list</span>
<span class="sd">            list of code output samples.</span>
<span class="sd">        x : array</span>
<span class="sd">            One or more locations in stochastic space at which to evaluate</span>
<span class="sd">            the surrogate.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        surr : array</span>
<span class="sd">            The interpolated values of the code output at input locations</span>
<span class="sd">            specified by x.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Computing the tensor grid of each multiindex l (xi_d below)</span>
        <span class="c1"># every time is slow. Instead store it globally, and only recompute when</span>
        <span class="c1"># self.l_norm has changed, when the flag init_interpolation = True.</span>
        <span class="c1"># This flag is set to True when self.analyse is executed</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_interpolation</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xi_d_per_l</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span><span class="p">:</span>
                <span class="c1"># all points corresponding to l</span>
                <span class="n">xi</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">xi_1d</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">l</span><span class="p">[</span><span class="n">n</span><span class="p">]]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">xi_d_per_l</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">xi</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">init_interpolation</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">surr</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span><span class="p">:</span>
            <span class="c1"># all points corresponding to l</span>
            <span class="c1"># xi = [self.xi_1d[n][l[n]] for n in range(self.N)]</span>
            <span class="c1"># xi_d = np.array(list(product(*xi)))</span>
            <span class="n">xi_d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi_d_per_l</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span>

            <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="n">xi_d</span><span class="p">:</span>
                <span class="c1"># indices of current collocation point</span>
                <span class="c1"># in corresponding 1d colloc points (self.xi_1d[n][l[n]])</span>
                <span class="c1"># These are the j of the 1D lagrange polynomials l_j(x), see</span>
                <span class="c1"># lagrange_poly subroutine</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi_1d</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">l</span><span class="p">[</span><span class="n">n</span><span class="p">]]</span> <span class="o">==</span> <span class="n">xi</span><span class="p">[</span><span class="n">n</span><span class="p">])</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)]</span>
                <span class="c1"># index of the code sample</span>
                <span class="n">sample_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">xi</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi_d</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

                <span class="c1"># values of Lagrange polynomials at x</span>
                <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">weight</span> <span class="o">=</span> <span class="p">[</span><span class="n">lagrange_poly</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi_1d</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">l</span><span class="p">[</span><span class="n">n</span><span class="p">]],</span> <span class="n">idx</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
                              <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)]</span>
                    <span class="n">surr</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comb_coef</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span> <span class="o">*</span> <span class="n">samples</span><span class="p">[</span><span class="n">sample_idx</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="c1"># batch setting, if multiple x values are presribed</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">weight</span> <span class="o">=</span> <span class="p">[</span><span class="n">lagrange_poly</span><span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="n">n</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi_1d</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">l</span><span class="p">[</span><span class="n">n</span><span class="p">]],</span> <span class="n">idx</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
                              <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)]</span>
                    <span class="n">surr</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comb_coef</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span> <span class="o">*</span> <span class="n">samples</span><span class="p">[</span><span class="n">sample_idx</span><span class="p">]</span> <span class="o">*</span> \
                        <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">surr</span>

    <span class="k">def</span> <span class="nf">get_sample_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qoi</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        qoi : str</span>
<span class="sd">            name of quantity of interest</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        array of all samples of qoi</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">qoi</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">qoi</span><span class="p">]))])</span>

    <span class="k">def</span> <span class="nf">adaptation_histogram</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plots a bar chart of the maximum order of the quadrature rule</span>
<span class="sd">        that is used in each dimension. Use in case of the dimension adaptive</span>
<span class="sd">        sampler to get an idea of which parameters were more refined than others.</span>
<span class="sd">        This gives only a first-order idea, as it only plots the max quad</span>
<span class="sd">        order independently per input parameter, so higher-order refinements</span>
<span class="sd">        that were made do not show up in the bar chart.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="s1">&#39;adapt_hist&#39;</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">])</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="s1">&#39;max quadrature order&#39;</span><span class="p">,</span>
                             <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Number of refinements = </span><span class="si">%d</span><span class="s1">&#39;</span>
                             <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">nadaptations</span><span class="p">)</span>
        <span class="c1"># find max quad order for every parameter</span>
        <span class="n">adapt_measure</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">adapt_measure</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="n">height</span><span class="o">=</span><span class="n">adapt_measure</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">params</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">vary</span><span class="o">.</span><span class="n">get_keys</span><span class="p">())</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">adapt_measure</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">rotation</span><span class="o">=</span><span class="mi">90</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">adaptation_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plots a color-coded table of the quadrature-order refinement.</span>
<span class="sd">        Shows in what order the parameters were refined, and unlike</span>
<span class="sd">        adaptation_histogram, this also shows higher-order refinements.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        **kwargs: can contain kwarg &#39;order&#39; to specify the order in which</span>
<span class="sd">        the variables on the x axis are plotted (e.g. in order of decreasing</span>
<span class="sd">        1st order Sobol index).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># if specified, plot the variables on the x axis in a given order</span>
        <span class="k">if</span> <span class="s1">&#39;order&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">order</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;order&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">order</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>

        <span class="n">l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span><span class="p">)[:,</span> <span class="n">order</span><span class="p">]</span>
        <span class="kn">import</span> <span class="nn">matplotlib</span> <span class="k">as</span> <span class="nn">mpl</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">[</span><span class="mi">12</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>

        <span class="c1"># max quad order</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
        <span class="n">cmap</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s1">&#39;Purples&#39;</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
        <span class="c1"># plot &#39;heat map&#39; of refinement</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">)</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span><span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">M</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">sm</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">ScalarMappable</span><span class="p">(</span><span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">)</span>
        <span class="n">sm</span><span class="o">.</span><span class="n">set_array</span><span class="p">([])</span>
        <span class="n">cb</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">sm</span><span class="p">)</span>
        <span class="c1"># plot the quad order in the middle of the colorbar intervals</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">M</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">M</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">tick_p</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">cb</span><span class="o">.</span><span class="n">set_ticks</span><span class="p">(</span><span class="n">tick_p</span><span class="p">)</span>
        <span class="n">cb</span><span class="o">.</span><span class="n">set_ticklabels</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">M</span><span class="p">))</span>
        <span class="n">cb</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;quadrature order&#39;</span><span class="p">)</span>
        <span class="c1"># plot the variables names on the x axis</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">vary</span><span class="o">.</span><span class="n">get_keys</span><span class="p">()))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_yticklabels</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="n">order</span><span class="p">],</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
        <span class="c1"># ax.set_yticks(range(l.shape[0]))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;iteration&#39;</span><span class="p">)</span>
        <span class="c1"># plt.yticks(rotation=90)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">plot_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plots the collocation points for 2 and 3 dimensional problems</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">xlabel</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;$x_1$&#39;</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;$x_2$&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi_d</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi_d</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;ro&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">mpl_toolkits.mplot3d</span> <span class="kn">import</span> <span class="n">Axes3D</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">,</span> <span class="n">xlabel</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;$x_1$&#39;</span><span class="p">,</span>
                                 <span class="n">ylabel</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;$x_2$&#39;</span><span class="p">,</span> <span class="n">zlabel</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;$x_3$&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi_d</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi_d</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi_d</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Will only plot for N = 2 or N = 3.&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SC2PCE</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">samples</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes the Polynomials Chaos Expansion coefficients from the SC</span>
<span class="sd">        expansion via a transformation of basis (Lagrange polynomials basis --&gt;</span>
<span class="sd">        orthonomial basis).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        samples : array</span>
<span class="sd">            SC code samples from which to compute the PCE coefficients</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pce_coefs : dict</span>
<span class="sd">            PCE coefficients per multi index l</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pce_coefs</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="s1">&#39;l_norm&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">l_norm</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;l_norm&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">l_norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span>

        <span class="k">if</span> <span class="s1">&#39;xi_d&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">xi_d</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;xi_d&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xi_d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi_d</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;pce_coefs&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pce_coefs</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">count_l</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">l_norm</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pce_coefs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="c1"># pce coefficients for current multi-index l</span>
                <span class="n">pce_coefs</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span> <span class="o">=</span> <span class="p">{}</span>

                <span class="c1"># 1d points generated by l</span>
                <span class="n">x_1d</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">xi_1d</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">l</span><span class="p">[</span><span class="n">n</span><span class="p">]]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)]</span>
                <span class="c1"># 1d Lagrange polynomials generated by l</span>
                <span class="c1"># EDIT: do not use chaospy for Lagrange, converts lagrange into monomial, requires</span>
                <span class="c1"># Vandermonde matrix inversion to find coefficients, which becomes</span>
                <span class="c1"># very ill conditioned rather quickly. Can no longer use cp.E to compute</span>
                <span class="c1"># integrals, use GQ instead</span>
                <span class="c1"># a_1d = [cp.lagrange_polynomial(sampler.xi_1d[n][l[n]]) for n in range(d)]</span>

                <span class="c1"># N-dimensional grid generated by l</span>
                <span class="n">x_l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">x_1d</span><span class="p">)))</span>

                <span class="c1"># all multi indices of the PCE expansion: k &lt;= l</span>
                <span class="n">k_norm</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">l</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)]))</span>

                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Computing PCE coefficients </span><span class="si">%d</span><span class="s1"> / </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">count_l</span><span class="p">,</span> <span class="n">l_norm</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">k_norm</span><span class="p">:</span>
                    <span class="c1"># product of the PCE basis function or order k - 1 and all</span>
                    <span class="c1"># Lagrange basis functions in a_1d, per dimension</span>
                    <span class="c1">#[[phi_k[0]*a_1d[0]], ..., [phi_k[N-1]*a_1d[N-1]]]</span>

                    <span class="c1"># orthogonal polynomial generated by chaospy</span>
                    <span class="n">phi_k</span> <span class="o">=</span> <span class="p">[</span><span class="n">cp</span><span class="o">.</span><span class="n">expansion</span><span class="o">.</span><span class="n">stieltjes</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                                         <span class="n">dist</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">params_distribution</span><span class="p">[</span><span class="n">n</span><span class="p">],</span>
                                         <span class="n">normed</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)]</span>

                    <span class="c1"># the polynomial order of each integrand phi_k*a_j = (k - 1) + (number of</span>
                    <span class="c1"># colloc. points - 1)</span>
                    <span class="n">orders</span> <span class="o">=</span> <span class="p">[(</span><span class="n">k</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi_1d</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">l</span><span class="p">[</span><span class="n">n</span><span class="p">]]</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)]</span>

                    <span class="c1"># will hold the products of PCE basis functions phi_k and lagrange</span>
                    <span class="c1"># interpolation polynomials a_1d</span>
                    <span class="n">cross_prod</span> <span class="o">=</span> <span class="p">[]</span>

                    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">):</span>
                        <span class="c1"># GQ using n points can exactly integrate polynomials of order 2n-1:</span>
                        <span class="c1"># solve for required number of points n when given order</span>
                        <span class="n">n_quad_points</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">orders</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>

                        <span class="c1"># generate Gaussian quad rule</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">params_distribution</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">cp</span><span class="o">.</span><span class="n">DiscreteUniform</span><span class="p">):</span>
                            <span class="n">xi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi_1d</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">l</span><span class="p">[</span><span class="n">n</span><span class="p">]]</span>
                            <span class="n">wi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wi_1d</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">l</span><span class="p">[</span><span class="n">n</span><span class="p">]]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">xi</span><span class="p">,</span> <span class="n">wi</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">generate_quadrature</span><span class="p">(</span>
                                <span class="n">n_quad_points</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">params_distribution</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">rule</span><span class="o">=</span><span class="s2">&quot;G&quot;</span><span class="p">)</span>
                            <span class="n">xi</span> <span class="o">=</span> <span class="n">xi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                        <span class="c1"># number of colloc points = number of Lagrange polynomials</span>
                        <span class="n">n_lagrange_poly</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi_1d</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">l</span><span class="p">[</span><span class="n">n</span><span class="p">]]</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>

                        <span class="c1"># compute the v coefficients = coefficients of SC2PCE mapping</span>
                        <span class="n">v_coefs_n</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_lagrange_poly</span><span class="p">):</span>
                            <span class="c1"># compute values of Lagrange polys at quadrature points</span>
                            <span class="n">l_j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">lagrange_poly</span><span class="p">(</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi_1d</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">l</span><span class="p">[</span><span class="n">n</span><span class="p">]],</span> <span class="n">j</span><span class="p">)</span>
                                            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">xi</span><span class="o">.</span><span class="n">size</span><span class="p">)])</span>
                            <span class="c1"># each coef is the integral of the lagrange poly times the current</span>
                            <span class="c1"># orthogonal PCE poly</span>
                            <span class="n">v_coefs_n</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">l_j</span> <span class="o">*</span> <span class="n">phi_k</span><span class="p">[</span><span class="n">n</span><span class="p">](</span><span class="n">xi</span><span class="p">)</span> <span class="o">*</span> <span class="n">wi</span><span class="p">))</span>
                        <span class="n">cross_prod</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v_coefs_n</span><span class="p">)</span>

                    <span class="c1"># tensor product of all integrals</span>
                    <span class="n">integrals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">cross_prod</span><span class="p">)))</span>
                    <span class="c1"># multiply over the number of parameters: v_prod = v_k1_j1 * ... * v_kd_jd</span>
                    <span class="n">v_prod</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">integrals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">v_prod</span> <span class="o">=</span> <span class="n">v_prod</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">v_prod</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

                    <span class="c1"># find corresponding code values</span>
                    <span class="n">f_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">samples</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">x</span> <span class="o">==</span> <span class="n">xi_d</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">x_l</span><span class="p">])</span>

                    <span class="c1"># the sum of all code sample * v_{k,j_1} * ... * v_{k,j_N}</span>
                    <span class="c1"># equals the PCE coefficient</span>
                    <span class="n">eta_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">f_k</span> <span class="o">*</span> <span class="n">v_prod</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

                    <span class="n">pce_coefs</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)][</span><span class="nb">tuple</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span> <span class="o">=</span> <span class="n">eta_k</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># pce coefs previously computed, just copy result</span>
                <span class="n">pce_coefs</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pce_coefs</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span>
            <span class="n">count_l</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;done&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pce_coefs</span>

    <span class="k">def</span> <span class="nf">get_pce_stats</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l_norm</span><span class="p">,</span> <span class="n">pce_coefs</span><span class="p">,</span> <span class="n">comb_coef</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the mean and the variance based on the PCE coefficients</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        l_norm : array</span>
<span class="sd">            array of quadrature order multi indices</span>
<span class="sd">        pce_coefs : tuple</span>
<span class="sd">            tuple of PCE coefficients computed by SC2PCE subroutine</span>
<span class="sd">        comb_coef : tuple</span>
<span class="sd">            tuple of combination coefficients computed by compute_comb_coef</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple with mean and variance based on the PCE coefficients</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Compute the PCE mean</span>
        <span class="n">k1</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>
        <span class="n">mean</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">l_norm</span><span class="p">:</span>
            <span class="n">mean</span> <span class="o">=</span> <span class="n">mean</span> <span class="o">+</span> <span class="n">comb_coef</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span> <span class="o">*</span> <span class="n">pce_coefs</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)][</span><span class="n">k1</span><span class="p">]</span>

        <span class="n">D</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">l_norm</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">var_k</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">l_norm</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="k">if</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="ow">in</span> <span class="n">pce_coefs</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">eta_k</span> <span class="o">=</span> <span class="n">pce_coefs</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)][</span><span class="nb">tuple</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span>
                    <span class="n">var_k</span> <span class="o">=</span> <span class="n">var_k</span> <span class="o">+</span> <span class="n">comb_coef</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span> <span class="o">*</span> <span class="n">eta_k</span>
            <span class="n">var_k</span> <span class="o">=</span> <span class="n">var_k</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">D</span> <span class="o">+</span> <span class="n">var_k</span>

        <span class="k">return</span> <span class="n">mean</span><span class="p">,</span> <span class="n">D</span>

    <span class="k">def</span> <span class="nf">get_pce_sobol_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qoi</span><span class="p">,</span> <span class="n">typ</span><span class="o">=</span><span class="s1">&#39;first_order&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes Sobol indices using Polynomials Chaos coefficients. These</span>
<span class="sd">        coefficients are computed from the SC expansion via a transformation</span>
<span class="sd">        of basis (SC2PCE subroutine). This works better than computing the</span>
<span class="sd">        Sobol indices directly from the SC expansion in the case of the</span>
<span class="sd">        dimension-adaptive sampler.</span>

<span class="sd">        Method: J.D. Jakeman et al, &quot;Adaptive multi-index collocation</span>
<span class="sd">        for uncertainty quantification and sensitivity analysis&quot;, 2019.</span>
<span class="sd">        (Page 18)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        qoi : str</span>
<span class="sd">            name of the Quantity of Interest for which to compute the indices</span>
<span class="sd">        typ : str</span>
<span class="sd">            Default = &#39;first_order&#39;. &#39;all&#39; is also possible</span>
<span class="sd">        **kwargs : dict</span>
<span class="sd">            if this contains &#39;samples&#39;, use these instead of the SC samples ]</span>
<span class="sd">            in the database</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Tuple</span>
<span class="sd">            Mean: PCE mean</span>
<span class="sd">            Var: PCE variance</span>
<span class="sd">            S_u: PCE Sobol indices, either the first order indices or all indices</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s1">&#39;samples&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;samples&#39;</span><span class="p">]</span>
            <span class="n">N_qoi</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">qoi</span><span class="p">]</span>
            <span class="n">N_qoi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_qoi</span>

        <span class="c1"># compute the PCE coefficients</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pce_coefs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SC2PCE</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>

        <span class="c1"># Compute the PCE mean (not really required)</span>
        <span class="n">k1</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>
        <span class="n">mean</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span><span class="p">:</span>
            <span class="n">mean</span> <span class="o">=</span> <span class="n">mean</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">comb_coef</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pce_coefs</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)][</span><span class="n">k1</span><span class="p">]</span>

        <span class="c1"># dict to hold the variance per multi index k</span>
        <span class="n">var</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># D = total PCE variance</span>
        <span class="n">D</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">var_k</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="k">if</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pce_coefs</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">eta_k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pce_coefs</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)][</span><span class="nb">tuple</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span>
                    <span class="n">var_k</span> <span class="o">=</span> <span class="n">var_k</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">comb_coef</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span> <span class="o">*</span> <span class="n">eta_k</span>
            <span class="n">var</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span> <span class="o">=</span> <span class="n">var_k</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">D</span> <span class="o">+</span> <span class="n">var</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Computing Sobol indices...&#39;</span><span class="p">)</span>
        <span class="c1"># Universe = (0, 1, ..., N - 1)</span>
        <span class="n">U</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>

        <span class="c1"># the powerset of U for either the first order or all Sobol indices</span>
        <span class="k">if</span> <span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;first_order&#39;</span><span class="p">:</span>
            <span class="n">P</span> <span class="o">=</span> <span class="p">[()]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">):</span>
                <span class="n">P</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># all indices u</span>
            <span class="n">P</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">powerset</span><span class="p">(</span><span class="n">U</span><span class="p">))</span>

        <span class="c1"># dict to hold the partial Sobol variances and Sobol indices</span>
        <span class="n">D_u</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">S_u</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">P</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="c1"># complement of u</span>
            <span class="n">u_prime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
            <span class="n">k</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">D_u</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N_qoi</span><span class="p">)</span>
            <span class="n">S_u</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N_qoi</span><span class="p">)</span>

            <span class="c1"># compute the set of multi indices corresponding to varying ONLY</span>
            <span class="c1"># the inputs indexed by u</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span><span class="p">:</span>
                <span class="c1"># assume l_i = 1 for all i in u&#39; until found otherwise</span>
                <span class="n">all_ones</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">for</span> <span class="n">i_up</span> <span class="ow">in</span> <span class="n">u_prime</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">l</span><span class="p">[</span><span class="n">i_up</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">all_ones</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">break</span>
                <span class="c1"># if l_i = 1 for all i in u&#39;</span>
                <span class="k">if</span> <span class="n">all_ones</span><span class="p">:</span>
                    <span class="c1"># assume all l_i for i in u are &gt; 1</span>
                    <span class="n">all_gt_one</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">for</span> <span class="n">i_u</span> <span class="ow">in</span> <span class="n">u</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">l</span><span class="p">[</span><span class="n">i_u</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">all_gt_one</span> <span class="o">=</span> <span class="kc">False</span>
                            <span class="k">break</span>
                    <span class="c1"># if both conditions above are True, the current l varies</span>
                    <span class="c1"># only inputs indexed by u, add this l to k</span>
                    <span class="k">if</span> <span class="n">all_gt_one</span><span class="p">:</span>
                        <span class="n">k</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>

            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Multi indices of dimension  </span><span class="si">%s</span><span class="s1"> are </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span>
            <span class="c1"># the partial variance of u is the sum of all variances index by k</span>
            <span class="k">for</span> <span class="n">k_u</span> <span class="ow">in</span> <span class="n">k</span><span class="p">:</span>
                <span class="n">D_u</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">D_u</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">var</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">k_u</span><span class="p">)]</span>

            <span class="c1"># normalize D_u by total variance D to get the Sobol index</span>
            <span class="n">S_u</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">D_u</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">/</span> <span class="n">D</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;done&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mean</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">D_u</span><span class="p">,</span> <span class="n">S_u</span>

    <span class="c1"># Start SC specific methods</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">compute_tensor_prod_u</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">wi</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">u_prime</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate tensor products of weights and collocation points</span>
<span class="sd">        with dimension of u and u&#39;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xi (array of floats): 1D colloction points</span>
<span class="sd">        wi (array of floats): 1D quadrature weights</span>
<span class="sd">        u  (array of int): dimensions</span>
<span class="sd">        u_prime (array of int): remaining dimensions (u union u&#39; = range(N))</span>

<span class="sd">        Returns</span>
<span class="sd">        dict of tensor products of weight and points for dimensions u and u&#39;</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># tensor products with dimension of u</span>
        <span class="n">xi_u</span> <span class="o">=</span> <span class="p">[</span><span class="n">xi</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">u</span><span class="p">]</span>
        <span class="n">wi_u</span> <span class="o">=</span> <span class="p">[</span><span class="n">wi</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">u</span><span class="p">]</span>

        <span class="n">xi_d_u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">xi_u</span><span class="p">)))</span>
        <span class="n">wi_d_u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">wi_u</span><span class="p">)))</span>

        <span class="c1"># tensor products with dimension of u&#39; (complement of u)</span>
        <span class="n">xi_u_prime</span> <span class="o">=</span> <span class="p">[</span><span class="n">xi</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">u_prime</span><span class="p">]</span>
        <span class="n">wi_u_prime</span> <span class="o">=</span> <span class="p">[</span><span class="n">wi</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">u_prime</span><span class="p">]</span>

        <span class="n">xi_d_u_prime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">xi_u_prime</span><span class="p">)))</span>
        <span class="n">wi_d_u_prime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">wi_u_prime</span><span class="p">)))</span>

        <span class="k">return</span> <span class="n">xi_d_u</span><span class="p">,</span> <span class="n">wi_d_u</span><span class="p">,</span> <span class="n">xi_d_u_prime</span><span class="p">,</span> <span class="n">wi_d_u_prime</span>

    <span class="k">def</span> <span class="nf">compute_marginal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qoi</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">u_prime</span><span class="p">,</span> <span class="n">diff</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes a marginal integral of the qoi(x) over the dimension defined</span>
<span class="sd">        by u_prime, for every x value in dimensions u</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        - qoi (str): name of the quantity of interest</span>
<span class="sd">        - u (array of int): dimensions which are not integrated</span>
<span class="sd">        - u_prime (array of int): dimensions which are integrated</span>
<span class="sd">        - diff (array of int): levels</span>

<span class="sd">        Returns</span>
<span class="sd">        - Values of the marginal integral</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># 1d weights and points of the levels in diff</span>
        <span class="n">xi</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">xi_1d</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">diff</span><span class="p">)[</span><span class="n">n</span><span class="p">]]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)]</span>
        <span class="n">wi</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">wi_1d</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">diff</span><span class="p">)[</span><span class="n">n</span><span class="p">]]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)]</span>

        <span class="c1"># compute tensor products and weights in dimension u and u&#39;</span>
        <span class="n">xi_d_u</span><span class="p">,</span> <span class="n">wi_d_u</span><span class="p">,</span> <span class="n">xi_d_u_prime</span><span class="p">,</span> <span class="n">wi_d_u_prime</span> <span class="o">=</span>\
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_tensor_prod_u</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">wi</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">u_prime</span><span class="p">)</span>

        <span class="n">idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">u_prime</span><span class="p">)))</span>
        <span class="c1"># marginals h = f*w&#39; integrated over u&#39;, so cardinality is that of u</span>
        <span class="n">h</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span> <span class="o">*</span> <span class="n">xi_d_u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i_u</span><span class="p">,</span> <span class="n">xi_d_u_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">xi_d_u</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i_up</span><span class="p">,</span> <span class="n">xi_d_u_prime_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">xi_d_u_prime</span><span class="p">):</span>
                <span class="n">xi_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">xi_d_u_</span><span class="p">,</span> <span class="n">xi_d_u_prime_</span><span class="p">))[</span><span class="n">idxs</span><span class="p">]</span>
                <span class="c1"># find the index of the corresponding code sample</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi_d</span> <span class="o">==</span> <span class="n">xi_s</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1"># perform quadrature</span>
                <span class="n">q_k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">qoi</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span>
                <span class="n">h</span><span class="p">[</span><span class="n">i_u</span><span class="p">]</span> <span class="o">+=</span> <span class="n">q_k</span> <span class="o">*</span> <span class="n">wi_d_u_prime</span><span class="p">[</span><span class="n">i_up</span><span class="p">]</span><span class="o">.</span><span class="n">prod</span><span class="p">()</span>
        <span class="c1"># return marginal and the weights of dimensions u</span>
        <span class="k">return</span> <span class="n">h</span><span class="p">,</span> <span class="n">wi_d_u</span>

    <span class="k">def</span> <span class="nf">get_sobol_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qoi</span><span class="p">,</span> <span class="n">typ</span><span class="o">=</span><span class="s1">&#39;first_order&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes Sobol indices using Stochastic Collocation. Method:</span>
<span class="sd">        Tang (2009), GLOBAL SENSITIVITY ANALYSIS  FOR STOCHASTIC COLLOCATION</span>
<span class="sd">        EXPANSION.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        qoi (str): name of the Quantity of Interest for which to compute the indices</span>
<span class="sd">        typ (str): Default = &#39;first_order&#39;. &#39;all&#39; is also possible</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Either the first order or all Sobol indices of qoi</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Computing Sobol indices...&#39;</span><span class="p">)</span>
        <span class="c1"># multi indices</span>
        <span class="n">U</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;first_order&#39;</span><span class="p">:</span>
            <span class="n">P</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">powerset</span><span class="p">(</span><span class="n">U</span><span class="p">))[</span><span class="mi">0</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
            <span class="c1"># all indices u</span>
            <span class="n">P</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">powerset</span><span class="p">(</span><span class="n">U</span><span class="p">))</span>

        <span class="c1"># get first two moments</span>
        <span class="n">mu</span><span class="p">,</span> <span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_moments</span><span class="p">(</span><span class="n">qoi</span><span class="p">)</span>

        <span class="c1"># partial variances</span>
        <span class="n">D_u</span> <span class="o">=</span> <span class="p">{</span><span class="n">P</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">mu</span><span class="o">**</span><span class="mi">2</span><span class="p">}</span>

        <span class="n">sobol</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">P</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>

            <span class="c1"># complement of u</span>
            <span class="n">u_prime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
            <span class="n">D_u</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span><span class="p">:</span>

                <span class="c1"># expand the multi-index indices of the tensor product</span>
                <span class="c1"># (Q^1_{i1} - Q^1_{i1-1}) X ... X (Q^1_{id) - Q^1_{id-1})</span>
                <span class="n">diff_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="p">[[</span><span class="n">k</span><span class="p">,</span> <span class="o">-</span><span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">l</span><span class="p">])))</span>

                <span class="c1"># perform analysis on each Q^1_l1 X ... X Q^1_l_N tensor prod</span>
                <span class="k">for</span> <span class="n">diff</span> <span class="ow">in</span> <span class="n">diff_idx</span><span class="p">:</span>

                    <span class="c1"># if any Q^1_li is below the minimim level, Q^1_li is defined</span>
                    <span class="c1"># as zero: do not compute this Q^1_l1 X ... X Q^1_l_N tensor prod</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">l_norm_min</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>

                        <span class="c1"># mariginal integral h, integrate over dimensions u&#39;</span>
                        <span class="n">h</span><span class="p">,</span> <span class="n">wi_d_u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_marginal</span><span class="p">(</span><span class="n">qoi</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">u_prime</span><span class="p">,</span> <span class="n">diff</span><span class="p">)</span>

                        <span class="c1"># square result and integrate over remaining dimensions u</span>
                        <span class="k">for</span> <span class="n">i_u</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">wi_d_u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                            <span class="n">D_u</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">diff</span><span class="p">))</span> <span class="o">*</span> <span class="n">h</span><span class="p">[</span><span class="n">i_u</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">wi_d_u</span><span class="p">[</span><span class="n">i_u</span><span class="p">]</span><span class="o">.</span><span class="n">prod</span><span class="p">()</span>

                <span class="c1">#D_u[u] = D_u[u].flatten()</span>

            <span class="c1"># all subsets of u</span>
            <span class="n">W</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">powerset</span><span class="p">(</span><span class="n">u</span><span class="p">))[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># partial variance of u</span>
            <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">W</span><span class="p">:</span>
                <span class="n">D_u</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">-=</span> <span class="n">D_u</span><span class="p">[</span><span class="n">w</span><span class="p">]</span>

            <span class="c1"># compute Sobol index, only include points where D &gt; 0</span>
            <span class="c1"># sobol[u] = D_u[u][idx_gt0]/D[idx_gt0]</span>
            <span class="n">sobol</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">D_u</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">/</span> <span class="n">D</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;done.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sobol</span>

    <span class="k">def</span> <span class="nf">get_uncertainty_amplification</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qoi</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes a measure that signifies the ratio of output to input</span>
<span class="sd">        uncertainty. It is computed as the (mean) Coefficient of Variation (V)</span>
<span class="sd">        of the output divided by the (mean) CV of the input.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        qoi (string): name of the Quantity of Interest</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        blowup (float): the ratio output CV / input CV</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">mean_f</span><span class="p">,</span> <span class="n">var_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_moments</span><span class="p">(</span><span class="n">qoi</span><span class="p">)</span>
        <span class="n">std_f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">var_f</span><span class="p">)</span>

        <span class="n">mean_xi</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">std_xi</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">CV_xi</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">params_distribution</span><span class="p">:</span>
            <span class="n">E</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">E</span><span class="p">(</span><span class="n">param</span><span class="p">)</span>
            <span class="n">Std</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">Std</span><span class="p">(</span><span class="n">param</span><span class="p">)</span>
            <span class="n">mean_xi</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
            <span class="n">std_xi</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Std</span><span class="p">)</span>
            <span class="n">CV_xi</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Std</span> <span class="o">/</span> <span class="n">E</span><span class="p">)</span>

        <span class="n">CV_in</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">CV_xi</span><span class="p">)</span>
        <span class="n">CV_out</span> <span class="o">=</span> <span class="n">std_f</span> <span class="o">/</span> <span class="n">mean_f</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">CV_out</span><span class="p">)</span> <span class="o">==</span> <span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">CV_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">CV_out</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
        <span class="n">blowup</span> <span class="o">=</span> <span class="n">CV_out</span> <span class="o">/</span> <span class="n">CV_in</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;-----------------&#39;</span><span class="p">)</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Mean CV input = </span><span class="si">%.4f</span><span class="s1"> </span><span class="si">%%</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="n">CV_in</span><span class="p">,</span> <span class="p">))</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Mean CV output = </span><span class="si">%.4f</span><span class="s1"> </span><span class="si">%%</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="n">CV_out</span><span class="p">,</span> <span class="p">))</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s1">&#39;Uncertainty amplification factor = </span><span class="si">%.4f</span><span class="s1">/</span><span class="si">%.4f</span><span class="s1"> = </span><span class="si">%.4f</span><span class="s1">&#39;</span> <span class="o">%</span>
            <span class="p">(</span><span class="n">CV_out</span><span class="p">,</span> <span class="n">CV_in</span><span class="p">,</span> <span class="n">blowup</span><span class="p">))</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;-----------------&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">blowup</span>


<span class="k">def</span> <span class="nf">powerset</span><span class="p">(</span><span class="n">iterable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;powerset([1,2,3]) --&gt; () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)</span>

<span class="sd">    Taken from: https://docs.python.org/3/library/itertools.html#recipes</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    iterable : iterable</span>
<span class="sd">        Input sequence</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">s</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">combinations</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">lagrange_poly</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x_i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Lagrange polynomials used for interpolation</span>

<span class="sd">    l_j(x) = product(x - x_m / x_j - x_m) with 0 &lt;= m &lt;= k</span>
<span class="sd">                                               and m !=j</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : float</span>
<span class="sd">        location at which to compute the polynomial</span>

<span class="sd">    x_i : list or array of float</span>
<span class="sd">        nodes of the Lagrange polynomials</span>

<span class="sd">    j : int</span>
<span class="sd">        index of node at which l_j(x_j) = 1</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        l_j(x) calculated as shown above.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">l_j</span> <span class="o">=</span> <span class="mf">1.0</span>

    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x_i</span><span class="p">)):</span>

        <span class="k">if</span> <span class="n">m</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
            <span class="n">denom</span> <span class="o">=</span> <span class="n">x_i</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">x_i</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>
            <span class="n">nom</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">x_i</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>

            <span class="n">l_j</span> <span class="o">*=</span> <span class="n">nom</span> <span class="o">/</span> <span class="n">denom</span>

    <span class="k">return</span> <span class="n">l_j</span>
    <span class="c1"># implementation below is more beautiful, but slower</span>
    <span class="c1"># x_i_ = np.delete(x_i, j)</span>
    <span class="c1"># return np.prod((x - x_i_) / (x_i[j] - x_i_))</span>


<span class="k">def</span> <span class="nf">setdiff2d</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the difference of two 2D arrays X and Y</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X : 2D numpy array</span>
<span class="sd">    Y : 2D numpy array</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    The difference X \\ Y as a 2D array</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">X</span><span class="p">))</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">Y</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">diff</span><span class="p">))</span>
</pre></div>

        </details>

            </section>
                <section id="SCAnalysisResults">
                                <div class="attr class">
        <a class="headerlink" href="#SCAnalysisResults">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">SCAnalysisResults</span><wbr>(<span class="base"><a href="results.html#AnalysisResults">easyvvuq.analysis.results.AnalysisResults</a></span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">SCAnalysisResults</span><span class="p">(</span><span class="n">AnalysisResults</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">_get_sobols_first</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qoi</span><span class="p">,</span> <span class="n">input_</span><span class="p">):</span>
        <span class="n">raw_dict</span> <span class="o">=</span> <span class="n">AnalysisResults</span><span class="o">.</span><span class="n">_keys_to_tuples</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="p">[</span><span class="s1">&#39;sobols_first&#39;</span><span class="p">])</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">raw_dict</span><span class="p">[</span><span class="n">AnalysisResults</span><span class="o">.</span><span class="n">_to_tuple</span><span class="p">(</span><span class="n">qoi</span><span class="p">)][</span><span class="n">input_</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">result</span><span class="p">)])</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">supported_stats</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Types of statistics supported by the describe method.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="s1">&#39;var&#39;</span><span class="p">,</span> <span class="s1">&#39;std&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_describe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qoi</span><span class="p">,</span> <span class="n">statistic</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">statistic</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">supported_stats</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="p">[</span><span class="s1">&#39;statistical_moments&#39;</span><span class="p">][</span><span class="n">qoi</span><span class="p">][</span><span class="n">statistic</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">surrogate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an SC surrogate model.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        A function that takes a dictionary of parameter - value pairs and returns</span>
<span class="sd">        a dictionary with the results (same output as decoder).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">surrogate_fn</span><span class="p">(</span><span class="n">inputs</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">swap</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">inputs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">]))</span><span class="o">.</span><span class="n">T</span>
            <span class="n">results</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">qoi</span><span class="p">,</span> <span class="n">swap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surrogate_</span><span class="p">(</span><span class="n">qoi</span><span class="p">,</span> <span class="n">values</span><span class="p">)))</span> <span class="k">for</span> <span class="n">qoi</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">qois</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">results</span>
        <span class="k">return</span> <span class="n">surrogate_fn</span>
</pre></div>

        </details>

            <div class="docstring"><p>Contains the analysis results.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>raw_data</strong> (obj):
An arbitrary object that contains raw analysis data.</li>
<li><strong>samples</strong> (pandas DataFrame):
Collated samples.</li>
<li><strong>qois</strong> (list of str):
List of qoi names used during the analysis.</li>
<li><strong>inputs</strong> (list of str):
List of input names used during the analysis.</li>
</ul>
</div>


                            <div id="SCAnalysisResults.supported_stats" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SCAnalysisResults.supported_stats">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">supported_stats</span><span class="signature">(self)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">supported_stats</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Types of statistics supported by the describe method.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="s1">&#39;var&#39;</span><span class="p">,</span> <span class="s1">&#39;std&#39;</span><span class="p">]</span>
</pre></div>

        </details>

            <div class="docstring"><p>Types of statistics supported by the describe method.</p>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>list of str</strong></li>
</ul>
</div>


                            </div>
                            <div id="SCAnalysisResults.surrogate" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SCAnalysisResults.surrogate">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">surrogate</span><span class="signature">(self)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">surrogate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an SC surrogate model.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        A function that takes a dictionary of parameter - value pairs and returns</span>
<span class="sd">        a dictionary with the results (same output as decoder).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">surrogate_fn</span><span class="p">(</span><span class="n">inputs</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">swap</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">inputs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">]))</span><span class="o">.</span><span class="n">T</span>
            <span class="n">results</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">qoi</span><span class="p">,</span> <span class="n">swap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surrogate_</span><span class="p">(</span><span class="n">qoi</span><span class="p">,</span> <span class="n">values</span><span class="p">)))</span> <span class="k">for</span> <span class="n">qoi</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">qois</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">results</span>
        <span class="k">return</span> <span class="n">surrogate_fn</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return an SC surrogate model.</p>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>A function that takes a dictionary of parameter - value pairs and returns</strong></li>
<li><strong>a dictionary with the results (same output as decoder).</strong></li>
</ul>
</div>


                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="results.html#AnalysisResults">easyvvuq.analysis.results.AnalysisResults</a></dt>
                                <dd id="SCAnalysisResults.__init__" class="function"><a href="results.html#AnalysisResults.__init__">AnalysisResults</a></dd>
                <dd id="SCAnalysisResults.sobols_first" class="function"><a href="results.html#AnalysisResults.sobols_first">sobols_first</a></dd>
                <dd id="SCAnalysisResults.sobols_second" class="function"><a href="results.html#AnalysisResults.sobols_second">sobols_second</a></dd>
                <dd id="SCAnalysisResults.sobols_total" class="function"><a href="results.html#AnalysisResults.sobols_total">sobols_total</a></dd>
                <dd id="SCAnalysisResults.describe" class="function"><a href="results.html#AnalysisResults.describe">describe</a></dd>
                <dd id="SCAnalysisResults.plot_sobols_treemap" class="function"><a href="results.html#AnalysisResults.plot_sobols_treemap">plot_sobols_treemap</a></dd>
                <dd id="SCAnalysisResults.plot_sobols_first" class="function"><a href="results.html#AnalysisResults.plot_sobols_first">plot_sobols_first</a></dd>
                <dd id="SCAnalysisResults.plot_moments" class="function"><a href="results.html#AnalysisResults.plot_moments">plot_moments</a></dd>
                <dd id="SCAnalysisResults.get_distribution" class="function"><a href="results.html#AnalysisResults.get_distribution">get_distribution</a></dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="SCAnalysis">
                                <div class="attr class">
        <a class="headerlink" href="#SCAnalysis">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">SCAnalysis</span><wbr>(<span class="base"><a href="base.html#BaseAnalysisElement">easyvvuq.analysis.base.BaseAnalysisElement</a></span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">SCAnalysis</span><span class="p">(</span><span class="n">BaseAnalysisElement</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sampler</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">qoi_cols</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sampler : SCSampler</span>
<span class="sd">            Sampler used to initiate the SC analysis</span>
<span class="sd">        qoi_cols : list or None</span>
<span class="sd">            Column names for quantities of interest (for which analysis is</span>
<span class="sd">            performed).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">sampler</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;SC analysis requires a paired sampler to be passed&#39;</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">qoi_cols</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Analysis element requires a list of &quot;</span>
                               <span class="s2">&quot;quantities of interest (qoi)&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">qoi_cols</span> <span class="o">=</span> <span class="n">qoi_cols</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_type</span> <span class="o">=</span> <span class="n">OutputType</span><span class="o">.</span><span class="n">SUMMARY</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span> <span class="o">=</span> <span class="n">sampler</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimension_adaptive</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">dimension_adaptive</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension_adaptive</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">adaptation_errors</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mean_history</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">std_history</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sparse</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">sparse</span>

    <span class="k">def</span> <span class="nf">element_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Name for this element for logging purposes&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;SC_Analysis&quot;</span>

    <span class="k">def</span> <span class="nf">element_version</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Version of this element for logging purposes&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;0.5&quot;</span>

    <span class="k">def</span> <span class="nf">save_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Saves the complete state of the analysis object to a pickle file,</span>
<span class="sd">        except the sampler object (self.samples).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename : string</span>
<span class="sd">            name to the file to write the state to</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Saving analysis state to </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">filename</span><span class="p">)</span>
        <span class="c1"># make a copy of the state, and do not store the sampler as well</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;sampler&#39;</span><span class="p">]</span>
        <span class="n">file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span>
        <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span>
        <span class="n">file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">load_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Loads the complete state of the analysis object from a</span>
<span class="sd">        pickle file, stored using save_state.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename : string</span>
<span class="sd">            name of the file to load</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Loading analysis state from </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">filename</span><span class="p">)</span>
        <span class="n">file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">state</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="n">file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">analyse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_frame</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">compute_moments</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">compute_Sobols</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform SC analysis on input `data_frame`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data_frame : pandas.DataFrame</span>
<span class="sd">            Input data for analysis.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Results dictionary with sub-dicts with keys:</span>
<span class="sd">            [&#39;statistical_moments&#39;, &#39;sobol_indices&#39;].</span>
<span class="sd">            Each dict has an entry for each item in `qoi_cols`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">data_frame</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Analysis element needs a data frame to &quot;</span>
                               <span class="s2">&quot;analyse&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_frame</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="ow">and</span> <span class="n">data_frame</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;No data in data frame passed to analyse element&quot;</span><span class="p">)</span>

        <span class="c1"># the number of uncertain parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">N</span>
        <span class="c1"># tensor grid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xi_d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">xi_d</span>
        <span class="c1"># the maximum level (quad order) of the (sparse) grid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">L</span>

        <span class="c1"># if L &lt; L_min: quadratures and interpolations are zero</span>
        <span class="c1"># For full tensor grid: there is only one level: L_min = L</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">L_min</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">polynomial_order</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">l_norm_min</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span>
        <span class="c1"># For sparse grid: one or more levels</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">L_min</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="c1"># multi indices (stored in l_norm) for isotropic sparse grid or</span>
            <span class="c1"># dimension-adaptive grid before the 1st refinement.</span>
            <span class="c1"># If dimension_adaptive and nadaptations &gt; 0: l_norm</span>
            <span class="c1"># is computed in self.adaptation_metric</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension_adaptive</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">nadaptations</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># the maximum level (quad order) of the (sparse) grid</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">compute_sparse_multi_idx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">l_norm_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="c1"># #compute generalized combination coefficients</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comb_coef</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_comb_coef</span><span class="p">()</span>

        <span class="c1"># 1d weights and points per level</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xi_1d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">xi_1d</span>
        <span class="c1"># self.wi_1d = self.compute_SC_weights(rule=self.sampler.quad_rule)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wi_1d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">wi_1d</span>

        <span class="c1"># Extract output values for each quantity of interest from Dataframe</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Loading samples...&#39;</span><span class="p">)</span>
        <span class="n">qoi_cols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qoi_cols</span>
        <span class="n">samples</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">qoi_cols</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">run_id</span> <span class="ow">in</span> <span class="n">data_frame</span><span class="p">[(</span><span class="s1">&#39;run_id&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span><span class="o">.</span><span class="n">unique</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">qoi_cols</span><span class="p">:</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">data_frame</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">data_frame</span><span class="p">[(</span><span class="s1">&#39;run_id&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">==</span> <span class="n">run_id</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
                <span class="n">samples</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">samples</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;done&#39;</span><span class="p">)</span>

        <span class="c1"># size of one code sample</span>
        <span class="c1"># TODO: change this to include QoI of different size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N_qoi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">qoi_cols</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span>

        <span class="c1"># assume that self.l_norm has changed, and that the interpolation</span>
        <span class="c1"># must be initialised, see sc_expansion subroutine</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_interpolation</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># TODO: same pce coefs must be computed for every qoi</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pce_coefs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SC2PCE</span><span class="p">(</span><span class="n">samples</span><span class="p">[</span><span class="n">qoi_cols</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>

        <span class="c1"># Compute descriptive statistics for each quantity of interest</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;statistical_moments&#39;</span><span class="p">:</span> <span class="p">{},</span>
                   <span class="s1">&#39;sobols_first&#39;</span><span class="p">:</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="p">{}</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">qoi_cols</span><span class="p">},</span>
                   <span class="s1">&#39;sobols&#39;</span><span class="p">:</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="p">{}</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">qoi_cols</span><span class="p">}}</span>

        <span class="k">if</span> <span class="n">compute_moments</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">qoi_k</span> <span class="ow">in</span> <span class="n">qoi_cols</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse</span><span class="p">:</span>
                    <span class="n">mean_k</span><span class="p">,</span> <span class="n">var_k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_moments</span><span class="p">(</span><span class="n">qoi_k</span><span class="p">)</span>
                    <span class="n">std_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">var_k</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">pce_coefs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SC2PCE</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">qoi_k</span><span class="p">])</span>
                    <span class="n">mean_k</span><span class="p">,</span> <span class="n">var_k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pce_stats</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span><span class="p">,</span> <span class="n">pce_coefs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comb_coef</span><span class="p">)</span>
                    <span class="n">std_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">var_k</span><span class="p">)</span>

                <span class="c1"># compute statistical moments</span>
                <span class="n">results</span><span class="p">[</span><span class="s1">&#39;statistical_moments&#39;</span><span class="p">][</span><span class="n">qoi_k</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;mean&#39;</span><span class="p">:</span> <span class="n">mean_k</span><span class="p">,</span>
                                                         <span class="s1">&#39;var&#39;</span><span class="p">:</span> <span class="n">var_k</span><span class="p">,</span>
                                                         <span class="s1">&#39;std&#39;</span><span class="p">:</span> <span class="n">std_k</span><span class="p">}</span>

        <span class="k">if</span> <span class="n">compute_Sobols</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">qoi_k</span> <span class="ow">in</span> <span class="n">qoi_cols</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse</span><span class="p">:</span>
                    <span class="n">results</span><span class="p">[</span><span class="s1">&#39;sobols&#39;</span><span class="p">][</span><span class="n">qoi_k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sobol_indices</span><span class="p">(</span><span class="n">qoi_k</span><span class="p">,</span> <span class="s1">&#39;first_order&#39;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;sobols&#39;</span><span class="p">][</span><span class="n">qoi_k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pce_sobol_indices</span><span class="p">(</span>
                        <span class="n">qoi_k</span><span class="p">,</span> <span class="s1">&#39;first_order&#39;</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">param_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">vary</span><span class="o">.</span><span class="n">get_keys</span><span class="p">()):</span>
                    <span class="n">results</span><span class="p">[</span><span class="s1">&#39;sobols_first&#39;</span><span class="p">][</span><span class="n">qoi_k</span><span class="p">][</span><span class="n">param_name</span><span class="p">]</span> <span class="o">=</span> \
                        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;sobols&#39;</span><span class="p">][</span><span class="n">qoi_k</span><span class="p">][(</span><span class="n">idx</span><span class="p">,)]</span>

        <span class="n">results</span> <span class="o">=</span> <span class="n">SCAnalysisResults</span><span class="p">(</span><span class="n">raw_data</span><span class="o">=</span><span class="n">results</span><span class="p">,</span> <span class="n">samples</span><span class="o">=</span><span class="n">data_frame</span><span class="p">,</span>
                                    <span class="n">qois</span><span class="o">=</span><span class="n">qoi_cols</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">vary</span><span class="o">.</span><span class="n">get_keys</span><span class="p">()))</span>
        <span class="n">results</span><span class="o">.</span><span class="n">surrogate_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surrogate</span>
        <span class="k">return</span> <span class="n">results</span>

    <span class="k">def</span> <span class="nf">compute_comb_coef</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute general combination coefficients. These are the coefficients</span>
<span class="sd">        multiplying the tensor products associated to each multi index l,</span>
<span class="sd">        see page 12 Gerstner &amp; Griebel, numerical integration using sparse grids</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s1">&#39;l_norm&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">l_norm</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;l_norm&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">l_norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span>

        <span class="n">comb_coef</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Computing combination coefficients...&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">l_norm</span><span class="p">:</span>
            <span class="n">coef</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="c1"># for every k, subtract all multi indices</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">l_norm</span><span class="p">:</span>
                <span class="n">z</span> <span class="o">=</span> <span class="n">l</span> <span class="o">-</span> <span class="n">k</span>
                <span class="c1"># if the results contains only 0&#39;s and 1&#39;s, then z is the</span>
                <span class="c1"># vector that can be formed from a tensor product of unit vectors</span>
                <span class="c1"># for which k+z is in self.l_norm</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">z</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)):</span>
                    <span class="n">coef</span> <span class="o">+=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">z</span><span class="p">))</span>
            <span class="n">comb_coef</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span> <span class="o">=</span> <span class="n">coef</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;done&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">comb_coef</span>

    <span class="k">def</span> <span class="nf">adapt_dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qoi</span><span class="p">,</span> <span class="n">data_frame</span><span class="p">,</span> <span class="n">store_stats_history</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">method</span><span class="o">=</span><span class="s1">&#39;surplus&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the adaptation metric and decide which of the admissible</span>
<span class="sd">        level indices to include in next iteration of the sparse grid. The</span>
<span class="sd">        adaptation metric is based on the hierarchical surplus, defined as the</span>
<span class="sd">        difference between the new code values of the admissible level indices,</span>
<span class="sd">        and the SC surrogate of the previous iteration. Alternatively, it can be</span>
<span class="sd">        based on the difference between the output mean of the current level,</span>
<span class="sd">        and the mean computed with one extra admissible index.</span>

<span class="sd">        This subroutine must be called AFTER the code is evaluated at</span>
<span class="sd">        the new points, but BEFORE the analysis is performed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        qoi : string</span>
<span class="sd">            the name of the quantity of interest which is used</span>
<span class="sd">            to base the adaptation metric on.</span>
<span class="sd">        data_frame : pandas.DataFrame</span>
<span class="sd">        store_stats_history : bool</span>
<span class="sd">            store the mean and variance at each refinement in self.mean_history</span>
<span class="sd">            and self.std_history. Used for checking convergence in the statistics</span>
<span class="sd">            over the refinement iterations</span>
<span class="sd">        method : string</span>
<span class="sd">            name of the refinement error, default is &#39;surplus&#39;. In this case the</span>
<span class="sd">            error is based on the hierarchical surplus, which is an interpolation</span>
<span class="sd">            based error. Another possibility is &#39;var&#39;,</span>
<span class="sd">            in which case the error is based on the difference in the </span>
<span class="sd">            variance between the current estimate and the estimate obtained</span>
<span class="sd">            when a particular candidate direction is added.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Refining sampling plan...&#39;</span><span class="p">)</span>
        <span class="c1"># load the code samples</span>
        <span class="n">samples</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_frame</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">run_id</span> <span class="ow">in</span> <span class="n">data_frame</span><span class="p">[(</span><span class="s1">&#39;run_id&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span><span class="o">.</span><span class="n">unique</span><span class="p">():</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">data_frame</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">data_frame</span><span class="p">[(</span><span class="s1">&#39;run_id&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">==</span> <span class="n">run_id</span><span class="p">][</span><span class="n">qoi</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
                <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;var&#39;</span><span class="p">:</span>
            <span class="n">all_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">admissible_idx</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xi_1d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">xi_1d</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wi_1d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">wi_1d</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pce_coefs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SC2PCE</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">l_norm</span><span class="o">=</span><span class="n">all_idx</span><span class="p">,</span>
                                         <span class="n">xi_d</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">xi_d</span><span class="p">)</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">var_l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pce_stats</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pce_coefs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comb_coef</span><span class="p">)</span>

        <span class="c1"># the currently accepted grid points</span>
        <span class="n">xi_d_accepted</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">generate_grid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span><span class="p">)</span>

        <span class="c1"># compute the hierarchical surplus based error for every admissible l</span>
        <span class="n">error</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">admissible_idx</span><span class="p">:</span>
            <span class="n">error</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># compute the error based on the hierarchical surplus (interpolation based)</span>
            <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;surplus&#39;</span><span class="p">:</span>
                <span class="c1"># collocation points of current level index l</span>
                <span class="n">X_l</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">xi_1d</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">l</span><span class="p">[</span><span class="n">n</span><span class="p">]]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)]</span>
                <span class="n">X_l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">X_l</span><span class="p">)))</span>
                <span class="c1"># only consider new points, subtract the accepted points</span>
                <span class="n">X_l</span> <span class="o">=</span> <span class="n">setdiff2d</span><span class="p">(</span><span class="n">X_l</span><span class="p">,</span> <span class="n">xi_d_accepted</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="n">X_l</span><span class="p">:</span>
                    <span class="c1"># find the location of the current xi in the global grid</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">xi</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">xi_d</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="c1"># hierarchical surplus error at xi</span>
                    <span class="n">hier_surplus</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">surrogate</span><span class="p">(</span><span class="n">qoi</span><span class="p">,</span> <span class="n">xi</span><span class="p">)</span>
                    <span class="k">if</span> <span class="s1">&#39;index&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                        <span class="n">hier_surplus</span> <span class="o">=</span> <span class="n">hier_surplus</span><span class="p">[</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">]]</span>
                        <span class="n">error</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">hier_surplus</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">error</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">hier_surplus</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">))</span>
                <span class="c1"># compute mean error over all points in X_l</span>
                <span class="n">error</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">error</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)])</span>
            <span class="c1"># compute the error based on quadrature of the variance</span>
            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;var&#39;</span><span class="p">:</span>
                <span class="c1"># create a candidate set of multi indices by adding the current</span>
                <span class="c1"># admissible index to l_norm</span>
                <span class="n">candidate_l_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span><span class="p">,</span> <span class="n">l</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">])))</span>
                <span class="c1"># now we must recompute the combination coefficients</span>
                <span class="n">c_l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_comb_coef</span><span class="p">(</span><span class="n">l_norm</span><span class="o">=</span><span class="n">candidate_l_norm</span><span class="p">)</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">var_candidate_l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pce_stats</span><span class="p">(</span><span class="n">candidate_l_norm</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pce_coefs</span><span class="p">,</span> <span class="n">c_l</span><span class="p">)</span>
                <span class="c1">#error in var</span>
                <span class="n">error</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">var_candidate_l</span> <span class="o">-</span> <span class="n">var_l</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Specified refinement method </span><span class="si">%s</span><span class="s1"> not recognized&#39;</span> <span class="o">%</span> <span class="n">method</span><span class="p">)</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Accepted are surplus, mean or var&#39;</span><span class="p">)</span>
                <span class="kn">import</span> <span class="nn">sys</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">error</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="c1"># logging.debug(&quot;Surplus error when l = %s is %s&quot; % (key, error[key]))</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Refinement error for l = </span><span class="si">%s</span><span class="s2"> is </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">error</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span>
        <span class="c1"># find the admissble index with the largest error</span>
        <span class="n">l_star</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">error</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">error</span><span class="o">.</span><span class="n">get</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">])</span>
        <span class="c1"># logging.debug(&#39;Selecting %s for refinement.&#39; % l_star)</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Selecting </span><span class="si">%s</span><span class="s1"> for refinement.&#39;</span> <span class="o">%</span> <span class="n">l_star</span><span class="p">)</span>
        <span class="c1"># add max error to list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adaptation_errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">error</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>

        <span class="c1"># add l_star to the current accepted level indices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span><span class="p">,</span> <span class="n">l_star</span><span class="p">))</span>
        <span class="c1"># if someone executes this function twice for some reason,</span>
        <span class="c1"># remove the duplicate l_star entry. Keep order unaltered</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">idx</span><span class="p">)])</span>

        <span class="c1"># peform the analyse step, but do not compute moments and Sobols</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analyse</span><span class="p">(</span><span class="n">data_frame</span><span class="p">,</span> <span class="n">compute_moments</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">compute_Sobols</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># if True store the mean and variance at eacht iteration of the adaptive</span>
        <span class="c1"># algorithmn</span>
        <span class="k">if</span> <span class="n">store_stats_history</span><span class="p">:</span>
            <span class="c1"># mean_f, var_f = self.get_moments(qoi)</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Storing moments of iteration </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">nadaptations</span><span class="p">)</span>
            <span class="n">pce_coefs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SC2PCE</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">mean_f</span><span class="p">,</span> <span class="n">var_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pce_stats</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span><span class="p">,</span> <span class="n">pce_coefs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comb_coef</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mean_history</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mean_f</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">std_history</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var_f</span><span class="p">)</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;done&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">merge_accepted_and_admissible</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;In the case of the dimension-adaptive sampler, there are 2 sets of</span>
<span class="sd">        quadrature multi indices. There are the accepted indices that are actually</span>
<span class="sd">        used in the analysis, and the admissible indices, of which some might</span>
<span class="sd">        move to the accepted set in subsequent iterations. This subroutine merges</span>
<span class="sd">        the two sets of multi indices by moving all admissible to the set of</span>
<span class="sd">        accepted indices.</span>
<span class="sd">        Do this at the end, when no more refinements will be executed. The</span>
<span class="sd">        samples related to the admissble indices are already computed, although</span>
<span class="sd">        not used in the analysis. By executing this subroutine at very end, all</span>
<span class="sd">        computed samples are used during the final postprocessing stage. Execute</span>
<span class="sd">        campaign.apply_analysis to let the new set of indices take effect.</span>
<span class="sd">        If further refinements are executed after all via sampler.look_ahead, the</span>
<span class="sd">        number of new admissible samples to be computed can be very high,</span>
<span class="sd">        especially in high dimensions. It is possible to undo the merge via</span>
<span class="sd">        analysis.undo_merge before new refinements are made. Execute</span>
<span class="sd">        campaign.apply_analysis again to let the old set of indices take effect.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s1">&#39;include&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">include</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;include&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">include</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">dimension_adaptive</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Moving admissible indices to the accepted set...&#39;</span><span class="p">)</span>
            <span class="c1"># make a backup of l_norm, such that undo_merge can revert back</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">l_norm_backup</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span><span class="p">)</span>
            <span class="c1"># merge admissible and accepted multi indices</span>
            <span class="k">if</span> <span class="n">level</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">merged_l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">admissible_idx</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">admissible_idx</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">admissible_idx</span><span class="p">:</span>
                    <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">l</span> <span class="o">==</span> <span class="n">L</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">L</span> <span class="o">&lt;=</span> <span class="n">level</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">include</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="n">admissible_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
                        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">admissible_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">admissible_idx</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">count</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">])</span>
                <span class="n">merged_l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span><span class="p">,</span> <span class="n">admissible_idx</span><span class="p">))</span>
            <span class="c1"># make sure final result contains only unique indices and store</span>
            <span class="c1">#results in l_norm</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">merged_l</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># return np.array([merged_l[i] for i in sorted(idx)])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">merged_l</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">idx</span><span class="p">)])</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;done&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">undo_merge</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This reverses the effect of the merge_accepted_and_admissble subroutine.</span>
<span class="sd">        Execute if further refinement are required after all.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">dimension_adaptive</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">l_norm_backup</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Restored old multi indices.&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_adaptation_errors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns self.adaptation_errors</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">adaptation_errors</span>

    <span class="k">def</span> <span class="nf">plot_stat_convergence</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plots the convergence of the statistical mean and std dev over the different</span>
<span class="sd">        refinements in a dimension-adaptive setting. Specifically the inf norm</span>
<span class="sd">        of the difference between the stats of iteration i and iteration i-1</span>
<span class="sd">        is plotted.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension_adaptive</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Only works for the dimension adaptive sampler.&#39;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="n">K</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mean_history</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">K</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Means from at least two refinements are required&#39;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">differ_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">K</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">differ_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">K</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">K</span><span class="p">):</span>
                <span class="n">differ_mean</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mean_history</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span>
                                                    <span class="bp">self</span><span class="o">.</span><span class="n">mean_history</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
                <span class="c1"># make relative</span>
                <span class="n">differ_mean</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">differ_mean</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mean_history</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span>
                                                                         <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>

                <span class="n">differ_std</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">std_history</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span>
                                                   <span class="bp">self</span><span class="o">.</span><span class="n">std_history</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
                <span class="c1"># make relative</span>
                <span class="n">differ_std</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">differ_std</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">std_history</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span>
                                                                       <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>

        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="s1">&#39;stat_conv&#39;</span><span class="p">)</span>
        <span class="n">ax1</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;moment convergence&#39;</span><span class="p">)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;iteration&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
        <span class="c1"># ax1.set_ylabel(r&#39;$ ||\mathrm{mean}_i - \mathrm{mean}_{i - 1}||_\infty$&#39;,</span>
        <span class="c1"># color=&#39;r&#39;, fontsize=12)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;relative error mean&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">K</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">differ_mean</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;+&#39;</span><span class="p">)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">labelcolor</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>

        <span class="n">ax2</span> <span class="o">=</span> <span class="n">ax1</span><span class="o">.</span><span class="n">twinx</span><span class="p">()</span>  <span class="c1"># instantiate a second axes that shares the same x-axis</span>

        <span class="c1"># ax2.set_ylabel(r&#39;$ ||\mathrm{var}_i - \mathrm{var}_{i - 1}||_\infty$&#39;,</span>
        <span class="c1"># color=&#39;b&#39;, fontsize=12)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;relative error variance&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">K</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">differ_std</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;*&#39;</span><span class="p">)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">labelcolor</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">surrogate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qoi</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">L</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Use sc_expansion UQP as a surrogate</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        qoi : str</span>
<span class="sd">            name of the qoi</span>
<span class="sd">        x : array</span>
<span class="sd">            location at which to evaluate the surrogate</span>
<span class="sd">        L : int</span>
<span class="sd">            level of the (sparse) grid, default = self.L</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        the interpolated value of qoi at x (float, (N_qoi,))</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc_expansion</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">qoi</span><span class="p">],</span> <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">quadrature</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qoi</span><span class="p">,</span> <span class="n">samples</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes a (Smolyak) quadrature</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        qoi : str</span>
<span class="sd">            name of the qoi</span>

<span class="sd">        samples: array</span>
<span class="sd">            compute the mean by setting samples = self.samples.</span>
<span class="sd">            To compute the variance, set samples = (self.samples - mean)**2</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        the quadrature of qoi</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">samples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">qoi</span><span class="p">]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">combination_technique</span><span class="p">(</span><span class="n">qoi</span><span class="p">,</span> <span class="n">samples</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">combination_technique</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qoi</span><span class="p">,</span> <span class="n">samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Efficient quadrature formulation for (sparse) grids. See:</span>

<span class="sd">            Gerstner, Griebel, &quot;Numerical integration using sparse grids&quot;</span>
<span class="sd">            Uses the general combination technique (page 12).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        qoi : str</span>
<span class="sd">            name of the qoi</span>

<span class="sd">        samples : array</span>
<span class="sd">            compute the mean by setting samples = self.samples.</span>
<span class="sd">            To compute the variance, set samples = (self.samples - mean)**2</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">samples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">qoi</span><span class="p">]</span>

        <span class="c1"># In the case of quadrature-based refinement, we need to specify</span>
        <span class="c1"># l_norm, comb_coef and xi_d other than the current defualt values</span>
        <span class="k">if</span> <span class="s1">&#39;l_norm&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">l_norm</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;l_norm&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">l_norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span>

        <span class="k">if</span> <span class="s1">&#39;comb_coef&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">comb_coef</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;comb_coef&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">comb_coef</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comb_coef</span>

        <span class="k">if</span> <span class="s1">&#39;xi_d&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">xi_d</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;xi_d&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xi_d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi_d</span>

        <span class="c1"># quadrature Q</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="c1"># loop over l</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">l_norm</span><span class="p">:</span>
            <span class="c1"># compute the tensor product of parameter and weight values</span>
            <span class="n">X_k</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">xi_1d</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">l</span><span class="p">[</span><span class="n">n</span><span class="p">]]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)]</span>
            <span class="n">W_k</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">wi_1d</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">l</span><span class="p">[</span><span class="n">n</span><span class="p">]]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)]</span>

            <span class="n">X_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">X_k</span><span class="p">)))</span>
            <span class="n">W_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">W_k</span><span class="p">)))</span>
            <span class="n">W_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">W_k</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">W_k</span> <span class="o">=</span> <span class="n">W_k</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">W_k</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">])</span>

            <span class="c1"># scaling factor of combination technique</span>
            <span class="n">W_k</span> <span class="o">=</span> <span class="n">W_k</span> <span class="o">*</span> <span class="n">comb_coef</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span>

            <span class="c1"># find corresponding code values</span>
            <span class="n">f_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">samples</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">x</span> <span class="o">==</span> <span class="n">xi_d</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">X_k</span><span class="p">])</span>

            <span class="c1"># quadrature of Q^1_{k1} X ... X Q^1_{kN} product</span>
            <span class="n">Q</span> <span class="o">=</span> <span class="n">Q</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">f_k</span> <span class="o">*</span> <span class="n">W_k</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="k">return</span> <span class="n">Q</span>

    <span class="k">def</span> <span class="nf">get_moments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qoi</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        qoi : str</span>
<span class="sd">            name of the qoi</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mean and variance of qoi (float (N_qoi,))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Computing moments...&#39;</span><span class="p">)</span>
        <span class="c1"># compute mean</span>
        <span class="n">mean_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">quadrature</span><span class="p">(</span><span class="n">qoi</span><span class="p">)</span>
        <span class="c1"># compute variance</span>
        <span class="n">variance_samples</span> <span class="o">=</span> <span class="p">[(</span><span class="n">sample</span> <span class="o">-</span> <span class="n">mean_f</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">sample</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">qoi</span><span class="p">]]</span>
        <span class="n">var_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">quadrature</span><span class="p">(</span><span class="n">qoi</span><span class="p">,</span> <span class="n">samples</span><span class="o">=</span><span class="n">variance_samples</span><span class="p">)</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;done&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mean_f</span><span class="p">,</span> <span class="n">var_f</span>

    <span class="k">def</span> <span class="nf">sc_expansion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">samples</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Non recursive implementation of the SC expansion. Performs interpolation</span>
<span class="sd">        of code output samples for both full and sparse grids.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        samples : list</span>
<span class="sd">            list of code output samples.</span>
<span class="sd">        x : array</span>
<span class="sd">            One or more locations in stochastic space at which to evaluate</span>
<span class="sd">            the surrogate.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        surr : array</span>
<span class="sd">            The interpolated values of the code output at input locations</span>
<span class="sd">            specified by x.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Computing the tensor grid of each multiindex l (xi_d below)</span>
        <span class="c1"># every time is slow. Instead store it globally, and only recompute when</span>
        <span class="c1"># self.l_norm has changed, when the flag init_interpolation = True.</span>
        <span class="c1"># This flag is set to True when self.analyse is executed</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_interpolation</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xi_d_per_l</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span><span class="p">:</span>
                <span class="c1"># all points corresponding to l</span>
                <span class="n">xi</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">xi_1d</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">l</span><span class="p">[</span><span class="n">n</span><span class="p">]]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">xi_d_per_l</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">xi</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">init_interpolation</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">surr</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span><span class="p">:</span>
            <span class="c1"># all points corresponding to l</span>
            <span class="c1"># xi = [self.xi_1d[n][l[n]] for n in range(self.N)]</span>
            <span class="c1"># xi_d = np.array(list(product(*xi)))</span>
            <span class="n">xi_d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi_d_per_l</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span>

            <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="n">xi_d</span><span class="p">:</span>
                <span class="c1"># indices of current collocation point</span>
                <span class="c1"># in corresponding 1d colloc points (self.xi_1d[n][l[n]])</span>
                <span class="c1"># These are the j of the 1D lagrange polynomials l_j(x), see</span>
                <span class="c1"># lagrange_poly subroutine</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi_1d</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">l</span><span class="p">[</span><span class="n">n</span><span class="p">]]</span> <span class="o">==</span> <span class="n">xi</span><span class="p">[</span><span class="n">n</span><span class="p">])</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)]</span>
                <span class="c1"># index of the code sample</span>
                <span class="n">sample_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">xi</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi_d</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

                <span class="c1"># values of Lagrange polynomials at x</span>
                <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">weight</span> <span class="o">=</span> <span class="p">[</span><span class="n">lagrange_poly</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi_1d</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">l</span><span class="p">[</span><span class="n">n</span><span class="p">]],</span> <span class="n">idx</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
                              <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)]</span>
                    <span class="n">surr</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comb_coef</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span> <span class="o">*</span> <span class="n">samples</span><span class="p">[</span><span class="n">sample_idx</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="c1"># batch setting, if multiple x values are presribed</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">weight</span> <span class="o">=</span> <span class="p">[</span><span class="n">lagrange_poly</span><span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="n">n</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi_1d</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">l</span><span class="p">[</span><span class="n">n</span><span class="p">]],</span> <span class="n">idx</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
                              <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)]</span>
                    <span class="n">surr</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comb_coef</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span> <span class="o">*</span> <span class="n">samples</span><span class="p">[</span><span class="n">sample_idx</span><span class="p">]</span> <span class="o">*</span> \
                        <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">surr</span>

    <span class="k">def</span> <span class="nf">get_sample_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qoi</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        qoi : str</span>
<span class="sd">            name of quantity of interest</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        array of all samples of qoi</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">qoi</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">qoi</span><span class="p">]))])</span>

    <span class="k">def</span> <span class="nf">adaptation_histogram</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plots a bar chart of the maximum order of the quadrature rule</span>
<span class="sd">        that is used in each dimension. Use in case of the dimension adaptive</span>
<span class="sd">        sampler to get an idea of which parameters were more refined than others.</span>
<span class="sd">        This gives only a first-order idea, as it only plots the max quad</span>
<span class="sd">        order independently per input parameter, so higher-order refinements</span>
<span class="sd">        that were made do not show up in the bar chart.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="s1">&#39;adapt_hist&#39;</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">])</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="s1">&#39;max quadrature order&#39;</span><span class="p">,</span>
                             <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Number of refinements = </span><span class="si">%d</span><span class="s1">&#39;</span>
                             <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">nadaptations</span><span class="p">)</span>
        <span class="c1"># find max quad order for every parameter</span>
        <span class="n">adapt_measure</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">adapt_measure</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="n">height</span><span class="o">=</span><span class="n">adapt_measure</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">params</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">vary</span><span class="o">.</span><span class="n">get_keys</span><span class="p">())</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">adapt_measure</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">rotation</span><span class="o">=</span><span class="mi">90</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">adaptation_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plots a color-coded table of the quadrature-order refinement.</span>
<span class="sd">        Shows in what order the parameters were refined, and unlike</span>
<span class="sd">        adaptation_histogram, this also shows higher-order refinements.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        **kwargs: can contain kwarg &#39;order&#39; to specify the order in which</span>
<span class="sd">        the variables on the x axis are plotted (e.g. in order of decreasing</span>
<span class="sd">        1st order Sobol index).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># if specified, plot the variables on the x axis in a given order</span>
        <span class="k">if</span> <span class="s1">&#39;order&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">order</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;order&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">order</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>

        <span class="n">l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span><span class="p">)[:,</span> <span class="n">order</span><span class="p">]</span>
        <span class="kn">import</span> <span class="nn">matplotlib</span> <span class="k">as</span> <span class="nn">mpl</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">[</span><span class="mi">12</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>

        <span class="c1"># max quad order</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
        <span class="n">cmap</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s1">&#39;Purples&#39;</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
        <span class="c1"># plot &#39;heat map&#39; of refinement</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">)</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span><span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">M</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">sm</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">ScalarMappable</span><span class="p">(</span><span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">)</span>
        <span class="n">sm</span><span class="o">.</span><span class="n">set_array</span><span class="p">([])</span>
        <span class="n">cb</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">sm</span><span class="p">)</span>
        <span class="c1"># plot the quad order in the middle of the colorbar intervals</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">M</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">M</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">tick_p</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">cb</span><span class="o">.</span><span class="n">set_ticks</span><span class="p">(</span><span class="n">tick_p</span><span class="p">)</span>
        <span class="n">cb</span><span class="o">.</span><span class="n">set_ticklabels</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">M</span><span class="p">))</span>
        <span class="n">cb</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;quadrature order&#39;</span><span class="p">)</span>
        <span class="c1"># plot the variables names on the x axis</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">vary</span><span class="o">.</span><span class="n">get_keys</span><span class="p">()))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_yticklabels</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="n">order</span><span class="p">],</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
        <span class="c1"># ax.set_yticks(range(l.shape[0]))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;iteration&#39;</span><span class="p">)</span>
        <span class="c1"># plt.yticks(rotation=90)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">plot_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plots the collocation points for 2 and 3 dimensional problems</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">xlabel</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;$x_1$&#39;</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;$x_2$&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi_d</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi_d</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;ro&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">mpl_toolkits.mplot3d</span> <span class="kn">import</span> <span class="n">Axes3D</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">,</span> <span class="n">xlabel</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;$x_1$&#39;</span><span class="p">,</span>
                                 <span class="n">ylabel</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;$x_2$&#39;</span><span class="p">,</span> <span class="n">zlabel</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;$x_3$&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi_d</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi_d</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi_d</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Will only plot for N = 2 or N = 3.&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SC2PCE</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">samples</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes the Polynomials Chaos Expansion coefficients from the SC</span>
<span class="sd">        expansion via a transformation of basis (Lagrange polynomials basis --&gt;</span>
<span class="sd">        orthonomial basis).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        samples : array</span>
<span class="sd">            SC code samples from which to compute the PCE coefficients</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pce_coefs : dict</span>
<span class="sd">            PCE coefficients per multi index l</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pce_coefs</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="s1">&#39;l_norm&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">l_norm</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;l_norm&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">l_norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span>

        <span class="k">if</span> <span class="s1">&#39;xi_d&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">xi_d</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;xi_d&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xi_d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi_d</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;pce_coefs&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pce_coefs</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">count_l</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">l_norm</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pce_coefs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="c1"># pce coefficients for current multi-index l</span>
                <span class="n">pce_coefs</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span> <span class="o">=</span> <span class="p">{}</span>

                <span class="c1"># 1d points generated by l</span>
                <span class="n">x_1d</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">xi_1d</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">l</span><span class="p">[</span><span class="n">n</span><span class="p">]]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)]</span>
                <span class="c1"># 1d Lagrange polynomials generated by l</span>
                <span class="c1"># EDIT: do not use chaospy for Lagrange, converts lagrange into monomial, requires</span>
                <span class="c1"># Vandermonde matrix inversion to find coefficients, which becomes</span>
                <span class="c1"># very ill conditioned rather quickly. Can no longer use cp.E to compute</span>
                <span class="c1"># integrals, use GQ instead</span>
                <span class="c1"># a_1d = [cp.lagrange_polynomial(sampler.xi_1d[n][l[n]]) for n in range(d)]</span>

                <span class="c1"># N-dimensional grid generated by l</span>
                <span class="n">x_l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">x_1d</span><span class="p">)))</span>

                <span class="c1"># all multi indices of the PCE expansion: k &lt;= l</span>
                <span class="n">k_norm</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">l</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)]))</span>

                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Computing PCE coefficients </span><span class="si">%d</span><span class="s1"> / </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">count_l</span><span class="p">,</span> <span class="n">l_norm</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">k_norm</span><span class="p">:</span>
                    <span class="c1"># product of the PCE basis function or order k - 1 and all</span>
                    <span class="c1"># Lagrange basis functions in a_1d, per dimension</span>
                    <span class="c1">#[[phi_k[0]*a_1d[0]], ..., [phi_k[N-1]*a_1d[N-1]]]</span>

                    <span class="c1"># orthogonal polynomial generated by chaospy</span>
                    <span class="n">phi_k</span> <span class="o">=</span> <span class="p">[</span><span class="n">cp</span><span class="o">.</span><span class="n">expansion</span><span class="o">.</span><span class="n">stieltjes</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                                         <span class="n">dist</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">params_distribution</span><span class="p">[</span><span class="n">n</span><span class="p">],</span>
                                         <span class="n">normed</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)]</span>

                    <span class="c1"># the polynomial order of each integrand phi_k*a_j = (k - 1) + (number of</span>
                    <span class="c1"># colloc. points - 1)</span>
                    <span class="n">orders</span> <span class="o">=</span> <span class="p">[(</span><span class="n">k</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi_1d</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">l</span><span class="p">[</span><span class="n">n</span><span class="p">]]</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)]</span>

                    <span class="c1"># will hold the products of PCE basis functions phi_k and lagrange</span>
                    <span class="c1"># interpolation polynomials a_1d</span>
                    <span class="n">cross_prod</span> <span class="o">=</span> <span class="p">[]</span>

                    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">):</span>
                        <span class="c1"># GQ using n points can exactly integrate polynomials of order 2n-1:</span>
                        <span class="c1"># solve for required number of points n when given order</span>
                        <span class="n">n_quad_points</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">orders</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>

                        <span class="c1"># generate Gaussian quad rule</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">params_distribution</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">cp</span><span class="o">.</span><span class="n">DiscreteUniform</span><span class="p">):</span>
                            <span class="n">xi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi_1d</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">l</span><span class="p">[</span><span class="n">n</span><span class="p">]]</span>
                            <span class="n">wi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wi_1d</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">l</span><span class="p">[</span><span class="n">n</span><span class="p">]]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">xi</span><span class="p">,</span> <span class="n">wi</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">generate_quadrature</span><span class="p">(</span>
                                <span class="n">n_quad_points</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">params_distribution</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">rule</span><span class="o">=</span><span class="s2">&quot;G&quot;</span><span class="p">)</span>
                            <span class="n">xi</span> <span class="o">=</span> <span class="n">xi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                        <span class="c1"># number of colloc points = number of Lagrange polynomials</span>
                        <span class="n">n_lagrange_poly</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi_1d</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">l</span><span class="p">[</span><span class="n">n</span><span class="p">]]</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>

                        <span class="c1"># compute the v coefficients = coefficients of SC2PCE mapping</span>
                        <span class="n">v_coefs_n</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_lagrange_poly</span><span class="p">):</span>
                            <span class="c1"># compute values of Lagrange polys at quadrature points</span>
                            <span class="n">l_j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">lagrange_poly</span><span class="p">(</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi_1d</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">l</span><span class="p">[</span><span class="n">n</span><span class="p">]],</span> <span class="n">j</span><span class="p">)</span>
                                            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">xi</span><span class="o">.</span><span class="n">size</span><span class="p">)])</span>
                            <span class="c1"># each coef is the integral of the lagrange poly times the current</span>
                            <span class="c1"># orthogonal PCE poly</span>
                            <span class="n">v_coefs_n</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">l_j</span> <span class="o">*</span> <span class="n">phi_k</span><span class="p">[</span><span class="n">n</span><span class="p">](</span><span class="n">xi</span><span class="p">)</span> <span class="o">*</span> <span class="n">wi</span><span class="p">))</span>
                        <span class="n">cross_prod</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v_coefs_n</span><span class="p">)</span>

                    <span class="c1"># tensor product of all integrals</span>
                    <span class="n">integrals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">cross_prod</span><span class="p">)))</span>
                    <span class="c1"># multiply over the number of parameters: v_prod = v_k1_j1 * ... * v_kd_jd</span>
                    <span class="n">v_prod</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">integrals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">v_prod</span> <span class="o">=</span> <span class="n">v_prod</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">v_prod</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

                    <span class="c1"># find corresponding code values</span>
                    <span class="n">f_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">samples</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">x</span> <span class="o">==</span> <span class="n">xi_d</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">x_l</span><span class="p">])</span>

                    <span class="c1"># the sum of all code sample * v_{k,j_1} * ... * v_{k,j_N}</span>
                    <span class="c1"># equals the PCE coefficient</span>
                    <span class="n">eta_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">f_k</span> <span class="o">*</span> <span class="n">v_prod</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

                    <span class="n">pce_coefs</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)][</span><span class="nb">tuple</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span> <span class="o">=</span> <span class="n">eta_k</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># pce coefs previously computed, just copy result</span>
                <span class="n">pce_coefs</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pce_coefs</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span>
            <span class="n">count_l</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;done&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pce_coefs</span>

    <span class="k">def</span> <span class="nf">get_pce_stats</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l_norm</span><span class="p">,</span> <span class="n">pce_coefs</span><span class="p">,</span> <span class="n">comb_coef</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the mean and the variance based on the PCE coefficients</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        l_norm : array</span>
<span class="sd">            array of quadrature order multi indices</span>
<span class="sd">        pce_coefs : tuple</span>
<span class="sd">            tuple of PCE coefficients computed by SC2PCE subroutine</span>
<span class="sd">        comb_coef : tuple</span>
<span class="sd">            tuple of combination coefficients computed by compute_comb_coef</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple with mean and variance based on the PCE coefficients</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Compute the PCE mean</span>
        <span class="n">k1</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>
        <span class="n">mean</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">l_norm</span><span class="p">:</span>
            <span class="n">mean</span> <span class="o">=</span> <span class="n">mean</span> <span class="o">+</span> <span class="n">comb_coef</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span> <span class="o">*</span> <span class="n">pce_coefs</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)][</span><span class="n">k1</span><span class="p">]</span>

        <span class="n">D</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">l_norm</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">var_k</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">l_norm</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="k">if</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="ow">in</span> <span class="n">pce_coefs</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">eta_k</span> <span class="o">=</span> <span class="n">pce_coefs</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)][</span><span class="nb">tuple</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span>
                    <span class="n">var_k</span> <span class="o">=</span> <span class="n">var_k</span> <span class="o">+</span> <span class="n">comb_coef</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span> <span class="o">*</span> <span class="n">eta_k</span>
            <span class="n">var_k</span> <span class="o">=</span> <span class="n">var_k</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">D</span> <span class="o">+</span> <span class="n">var_k</span>

        <span class="k">return</span> <span class="n">mean</span><span class="p">,</span> <span class="n">D</span>

    <span class="k">def</span> <span class="nf">get_pce_sobol_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qoi</span><span class="p">,</span> <span class="n">typ</span><span class="o">=</span><span class="s1">&#39;first_order&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes Sobol indices using Polynomials Chaos coefficients. These</span>
<span class="sd">        coefficients are computed from the SC expansion via a transformation</span>
<span class="sd">        of basis (SC2PCE subroutine). This works better than computing the</span>
<span class="sd">        Sobol indices directly from the SC expansion in the case of the</span>
<span class="sd">        dimension-adaptive sampler.</span>

<span class="sd">        Method: J.D. Jakeman et al, &quot;Adaptive multi-index collocation</span>
<span class="sd">        for uncertainty quantification and sensitivity analysis&quot;, 2019.</span>
<span class="sd">        (Page 18)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        qoi : str</span>
<span class="sd">            name of the Quantity of Interest for which to compute the indices</span>
<span class="sd">        typ : str</span>
<span class="sd">            Default = &#39;first_order&#39;. &#39;all&#39; is also possible</span>
<span class="sd">        **kwargs : dict</span>
<span class="sd">            if this contains &#39;samples&#39;, use these instead of the SC samples ]</span>
<span class="sd">            in the database</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Tuple</span>
<span class="sd">            Mean: PCE mean</span>
<span class="sd">            Var: PCE variance</span>
<span class="sd">            S_u: PCE Sobol indices, either the first order indices or all indices</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s1">&#39;samples&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;samples&#39;</span><span class="p">]</span>
            <span class="n">N_qoi</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">qoi</span><span class="p">]</span>
            <span class="n">N_qoi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_qoi</span>

        <span class="c1"># compute the PCE coefficients</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pce_coefs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SC2PCE</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>

        <span class="c1"># Compute the PCE mean (not really required)</span>
        <span class="n">k1</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>
        <span class="n">mean</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span><span class="p">:</span>
            <span class="n">mean</span> <span class="o">=</span> <span class="n">mean</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">comb_coef</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pce_coefs</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)][</span><span class="n">k1</span><span class="p">]</span>

        <span class="c1"># dict to hold the variance per multi index k</span>
        <span class="n">var</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># D = total PCE variance</span>
        <span class="n">D</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">var_k</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="k">if</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pce_coefs</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">eta_k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pce_coefs</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)][</span><span class="nb">tuple</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span>
                    <span class="n">var_k</span> <span class="o">=</span> <span class="n">var_k</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">comb_coef</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span> <span class="o">*</span> <span class="n">eta_k</span>
            <span class="n">var</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span> <span class="o">=</span> <span class="n">var_k</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">D</span> <span class="o">+</span> <span class="n">var</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Computing Sobol indices...&#39;</span><span class="p">)</span>
        <span class="c1"># Universe = (0, 1, ..., N - 1)</span>
        <span class="n">U</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>

        <span class="c1"># the powerset of U for either the first order or all Sobol indices</span>
        <span class="k">if</span> <span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;first_order&#39;</span><span class="p">:</span>
            <span class="n">P</span> <span class="o">=</span> <span class="p">[()]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">):</span>
                <span class="n">P</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># all indices u</span>
            <span class="n">P</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">powerset</span><span class="p">(</span><span class="n">U</span><span class="p">))</span>

        <span class="c1"># dict to hold the partial Sobol variances and Sobol indices</span>
        <span class="n">D_u</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">S_u</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">P</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="c1"># complement of u</span>
            <span class="n">u_prime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
            <span class="n">k</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">D_u</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N_qoi</span><span class="p">)</span>
            <span class="n">S_u</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N_qoi</span><span class="p">)</span>

            <span class="c1"># compute the set of multi indices corresponding to varying ONLY</span>
            <span class="c1"># the inputs indexed by u</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span><span class="p">:</span>
                <span class="c1"># assume l_i = 1 for all i in u&#39; until found otherwise</span>
                <span class="n">all_ones</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">for</span> <span class="n">i_up</span> <span class="ow">in</span> <span class="n">u_prime</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">l</span><span class="p">[</span><span class="n">i_up</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">all_ones</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">break</span>
                <span class="c1"># if l_i = 1 for all i in u&#39;</span>
                <span class="k">if</span> <span class="n">all_ones</span><span class="p">:</span>
                    <span class="c1"># assume all l_i for i in u are &gt; 1</span>
                    <span class="n">all_gt_one</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">for</span> <span class="n">i_u</span> <span class="ow">in</span> <span class="n">u</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">l</span><span class="p">[</span><span class="n">i_u</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">all_gt_one</span> <span class="o">=</span> <span class="kc">False</span>
                            <span class="k">break</span>
                    <span class="c1"># if both conditions above are True, the current l varies</span>
                    <span class="c1"># only inputs indexed by u, add this l to k</span>
                    <span class="k">if</span> <span class="n">all_gt_one</span><span class="p">:</span>
                        <span class="n">k</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>

            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Multi indices of dimension  </span><span class="si">%s</span><span class="s1"> are </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span>
            <span class="c1"># the partial variance of u is the sum of all variances index by k</span>
            <span class="k">for</span> <span class="n">k_u</span> <span class="ow">in</span> <span class="n">k</span><span class="p">:</span>
                <span class="n">D_u</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">D_u</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">var</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">k_u</span><span class="p">)]</span>

            <span class="c1"># normalize D_u by total variance D to get the Sobol index</span>
            <span class="n">S_u</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">D_u</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">/</span> <span class="n">D</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;done&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mean</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">D_u</span><span class="p">,</span> <span class="n">S_u</span>

    <span class="c1"># Start SC specific methods</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">compute_tensor_prod_u</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">wi</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">u_prime</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate tensor products of weights and collocation points</span>
<span class="sd">        with dimension of u and u&#39;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xi (array of floats): 1D colloction points</span>
<span class="sd">        wi (array of floats): 1D quadrature weights</span>
<span class="sd">        u  (array of int): dimensions</span>
<span class="sd">        u_prime (array of int): remaining dimensions (u union u&#39; = range(N))</span>

<span class="sd">        Returns</span>
<span class="sd">        dict of tensor products of weight and points for dimensions u and u&#39;</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># tensor products with dimension of u</span>
        <span class="n">xi_u</span> <span class="o">=</span> <span class="p">[</span><span class="n">xi</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">u</span><span class="p">]</span>
        <span class="n">wi_u</span> <span class="o">=</span> <span class="p">[</span><span class="n">wi</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">u</span><span class="p">]</span>

        <span class="n">xi_d_u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">xi_u</span><span class="p">)))</span>
        <span class="n">wi_d_u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">wi_u</span><span class="p">)))</span>

        <span class="c1"># tensor products with dimension of u&#39; (complement of u)</span>
        <span class="n">xi_u_prime</span> <span class="o">=</span> <span class="p">[</span><span class="n">xi</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">u_prime</span><span class="p">]</span>
        <span class="n">wi_u_prime</span> <span class="o">=</span> <span class="p">[</span><span class="n">wi</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">u_prime</span><span class="p">]</span>

        <span class="n">xi_d_u_prime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">xi_u_prime</span><span class="p">)))</span>
        <span class="n">wi_d_u_prime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">wi_u_prime</span><span class="p">)))</span>

        <span class="k">return</span> <span class="n">xi_d_u</span><span class="p">,</span> <span class="n">wi_d_u</span><span class="p">,</span> <span class="n">xi_d_u_prime</span><span class="p">,</span> <span class="n">wi_d_u_prime</span>

    <span class="k">def</span> <span class="nf">compute_marginal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qoi</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">u_prime</span><span class="p">,</span> <span class="n">diff</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes a marginal integral of the qoi(x) over the dimension defined</span>
<span class="sd">        by u_prime, for every x value in dimensions u</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        - qoi (str): name of the quantity of interest</span>
<span class="sd">        - u (array of int): dimensions which are not integrated</span>
<span class="sd">        - u_prime (array of int): dimensions which are integrated</span>
<span class="sd">        - diff (array of int): levels</span>

<span class="sd">        Returns</span>
<span class="sd">        - Values of the marginal integral</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># 1d weights and points of the levels in diff</span>
        <span class="n">xi</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">xi_1d</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">diff</span><span class="p">)[</span><span class="n">n</span><span class="p">]]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)]</span>
        <span class="n">wi</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">wi_1d</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">diff</span><span class="p">)[</span><span class="n">n</span><span class="p">]]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)]</span>

        <span class="c1"># compute tensor products and weights in dimension u and u&#39;</span>
        <span class="n">xi_d_u</span><span class="p">,</span> <span class="n">wi_d_u</span><span class="p">,</span> <span class="n">xi_d_u_prime</span><span class="p">,</span> <span class="n">wi_d_u_prime</span> <span class="o">=</span>\
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_tensor_prod_u</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">wi</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">u_prime</span><span class="p">)</span>

        <span class="n">idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">u_prime</span><span class="p">)))</span>
        <span class="c1"># marginals h = f*w&#39; integrated over u&#39;, so cardinality is that of u</span>
        <span class="n">h</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span> <span class="o">*</span> <span class="n">xi_d_u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i_u</span><span class="p">,</span> <span class="n">xi_d_u_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">xi_d_u</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i_up</span><span class="p">,</span> <span class="n">xi_d_u_prime_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">xi_d_u_prime</span><span class="p">):</span>
                <span class="n">xi_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">xi_d_u_</span><span class="p">,</span> <span class="n">xi_d_u_prime_</span><span class="p">))[</span><span class="n">idxs</span><span class="p">]</span>
                <span class="c1"># find the index of the corresponding code sample</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi_d</span> <span class="o">==</span> <span class="n">xi_s</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1"># perform quadrature</span>
                <span class="n">q_k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">qoi</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span>
                <span class="n">h</span><span class="p">[</span><span class="n">i_u</span><span class="p">]</span> <span class="o">+=</span> <span class="n">q_k</span> <span class="o">*</span> <span class="n">wi_d_u_prime</span><span class="p">[</span><span class="n">i_up</span><span class="p">]</span><span class="o">.</span><span class="n">prod</span><span class="p">()</span>
        <span class="c1"># return marginal and the weights of dimensions u</span>
        <span class="k">return</span> <span class="n">h</span><span class="p">,</span> <span class="n">wi_d_u</span>

    <span class="k">def</span> <span class="nf">get_sobol_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qoi</span><span class="p">,</span> <span class="n">typ</span><span class="o">=</span><span class="s1">&#39;first_order&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes Sobol indices using Stochastic Collocation. Method:</span>
<span class="sd">        Tang (2009), GLOBAL SENSITIVITY ANALYSIS  FOR STOCHASTIC COLLOCATION</span>
<span class="sd">        EXPANSION.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        qoi (str): name of the Quantity of Interest for which to compute the indices</span>
<span class="sd">        typ (str): Default = &#39;first_order&#39;. &#39;all&#39; is also possible</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Either the first order or all Sobol indices of qoi</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Computing Sobol indices...&#39;</span><span class="p">)</span>
        <span class="c1"># multi indices</span>
        <span class="n">U</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;first_order&#39;</span><span class="p">:</span>
            <span class="n">P</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">powerset</span><span class="p">(</span><span class="n">U</span><span class="p">))[</span><span class="mi">0</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
            <span class="c1"># all indices u</span>
            <span class="n">P</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">powerset</span><span class="p">(</span><span class="n">U</span><span class="p">))</span>

        <span class="c1"># get first two moments</span>
        <span class="n">mu</span><span class="p">,</span> <span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_moments</span><span class="p">(</span><span class="n">qoi</span><span class="p">)</span>

        <span class="c1"># partial variances</span>
        <span class="n">D_u</span> <span class="o">=</span> <span class="p">{</span><span class="n">P</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">mu</span><span class="o">**</span><span class="mi">2</span><span class="p">}</span>

        <span class="n">sobol</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">P</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>

            <span class="c1"># complement of u</span>
            <span class="n">u_prime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
            <span class="n">D_u</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span><span class="p">:</span>

                <span class="c1"># expand the multi-index indices of the tensor product</span>
                <span class="c1"># (Q^1_{i1} - Q^1_{i1-1}) X ... X (Q^1_{id) - Q^1_{id-1})</span>
                <span class="n">diff_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="p">[[</span><span class="n">k</span><span class="p">,</span> <span class="o">-</span><span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">l</span><span class="p">])))</span>

                <span class="c1"># perform analysis on each Q^1_l1 X ... X Q^1_l_N tensor prod</span>
                <span class="k">for</span> <span class="n">diff</span> <span class="ow">in</span> <span class="n">diff_idx</span><span class="p">:</span>

                    <span class="c1"># if any Q^1_li is below the minimim level, Q^1_li is defined</span>
                    <span class="c1"># as zero: do not compute this Q^1_l1 X ... X Q^1_l_N tensor prod</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">l_norm_min</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>

                        <span class="c1"># mariginal integral h, integrate over dimensions u&#39;</span>
                        <span class="n">h</span><span class="p">,</span> <span class="n">wi_d_u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_marginal</span><span class="p">(</span><span class="n">qoi</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">u_prime</span><span class="p">,</span> <span class="n">diff</span><span class="p">)</span>

                        <span class="c1"># square result and integrate over remaining dimensions u</span>
                        <span class="k">for</span> <span class="n">i_u</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">wi_d_u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                            <span class="n">D_u</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">diff</span><span class="p">))</span> <span class="o">*</span> <span class="n">h</span><span class="p">[</span><span class="n">i_u</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">wi_d_u</span><span class="p">[</span><span class="n">i_u</span><span class="p">]</span><span class="o">.</span><span class="n">prod</span><span class="p">()</span>

                <span class="c1">#D_u[u] = D_u[u].flatten()</span>

            <span class="c1"># all subsets of u</span>
            <span class="n">W</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">powerset</span><span class="p">(</span><span class="n">u</span><span class="p">))[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># partial variance of u</span>
            <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">W</span><span class="p">:</span>
                <span class="n">D_u</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">-=</span> <span class="n">D_u</span><span class="p">[</span><span class="n">w</span><span class="p">]</span>

            <span class="c1"># compute Sobol index, only include points where D &gt; 0</span>
            <span class="c1"># sobol[u] = D_u[u][idx_gt0]/D[idx_gt0]</span>
            <span class="n">sobol</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">D_u</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">/</span> <span class="n">D</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;done.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sobol</span>

    <span class="k">def</span> <span class="nf">get_uncertainty_amplification</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qoi</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes a measure that signifies the ratio of output to input</span>
<span class="sd">        uncertainty. It is computed as the (mean) Coefficient of Variation (V)</span>
<span class="sd">        of the output divided by the (mean) CV of the input.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        qoi (string): name of the Quantity of Interest</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        blowup (float): the ratio output CV / input CV</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">mean_f</span><span class="p">,</span> <span class="n">var_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_moments</span><span class="p">(</span><span class="n">qoi</span><span class="p">)</span>
        <span class="n">std_f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">var_f</span><span class="p">)</span>

        <span class="n">mean_xi</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">std_xi</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">CV_xi</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">params_distribution</span><span class="p">:</span>
            <span class="n">E</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">E</span><span class="p">(</span><span class="n">param</span><span class="p">)</span>
            <span class="n">Std</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">Std</span><span class="p">(</span><span class="n">param</span><span class="p">)</span>
            <span class="n">mean_xi</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
            <span class="n">std_xi</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Std</span><span class="p">)</span>
            <span class="n">CV_xi</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Std</span> <span class="o">/</span> <span class="n">E</span><span class="p">)</span>

        <span class="n">CV_in</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">CV_xi</span><span class="p">)</span>
        <span class="n">CV_out</span> <span class="o">=</span> <span class="n">std_f</span> <span class="o">/</span> <span class="n">mean_f</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">CV_out</span><span class="p">)</span> <span class="o">==</span> <span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">CV_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">CV_out</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
        <span class="n">blowup</span> <span class="o">=</span> <span class="n">CV_out</span> <span class="o">/</span> <span class="n">CV_in</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;-----------------&#39;</span><span class="p">)</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Mean CV input = </span><span class="si">%.4f</span><span class="s1"> </span><span class="si">%%</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="n">CV_in</span><span class="p">,</span> <span class="p">))</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Mean CV output = </span><span class="si">%.4f</span><span class="s1"> </span><span class="si">%%</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="n">CV_out</span><span class="p">,</span> <span class="p">))</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s1">&#39;Uncertainty amplification factor = </span><span class="si">%.4f</span><span class="s1">/</span><span class="si">%.4f</span><span class="s1"> = </span><span class="si">%.4f</span><span class="s1">&#39;</span> <span class="o">%</span>
            <span class="p">(</span><span class="n">CV_out</span><span class="p">,</span> <span class="n">CV_in</span><span class="p">,</span> <span class="n">blowup</span><span class="p">))</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;-----------------&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">blowup</span>
</pre></div>

        </details>

            <div class="docstring"><p>Base class for all EasyVVUQ analysis elements.</p>

<h2 id="attributes">Attributes</h2>
</div>


                            <div id="SCAnalysis.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SCAnalysis.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">SCAnalysis</span><span class="signature">(sampler=None, qoi_cols=None)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sampler</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">qoi_cols</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sampler : SCSampler</span>
<span class="sd">            Sampler used to initiate the SC analysis</span>
<span class="sd">        qoi_cols : list or None</span>
<span class="sd">            Column names for quantities of interest (for which analysis is</span>
<span class="sd">            performed).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">sampler</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;SC analysis requires a paired sampler to be passed&#39;</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">qoi_cols</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Analysis element requires a list of &quot;</span>
                               <span class="s2">&quot;quantities of interest (qoi)&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">qoi_cols</span> <span class="o">=</span> <span class="n">qoi_cols</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_type</span> <span class="o">=</span> <span class="n">OutputType</span><span class="o">.</span><span class="n">SUMMARY</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span> <span class="o">=</span> <span class="n">sampler</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimension_adaptive</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">dimension_adaptive</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension_adaptive</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">adaptation_errors</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mean_history</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">std_history</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sparse</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">sparse</span>
</pre></div>

        </details>

            <div class="docstring"><h6 id="parameters">Parameters</h6>

<ul>
<li><strong>sampler</strong> (SCSampler):
Sampler used to initiate the SC analysis</li>
<li><strong>qoi_cols</strong> (list or None):
Column names for quantities of interest (for which analysis is
performed).</li>
</ul>
</div>


                            </div>
                            <div id="SCAnalysis.element_name" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SCAnalysis.element_name">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">element_name</span><span class="signature">(self)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">element_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Name for this element for logging purposes&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;SC_Analysis&quot;</span>
</pre></div>

        </details>

            <div class="docstring"><p>Name for this element for logging purposes</p>
</div>


                            </div>
                            <div id="SCAnalysis.element_version" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SCAnalysis.element_version">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">element_version</span><span class="signature">(self)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">element_version</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Version of this element for logging purposes&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;0.5&quot;</span>
</pre></div>

        </details>

            <div class="docstring"><p>Version of this element for logging purposes</p>
</div>


                            </div>
                            <div id="SCAnalysis.save_state" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SCAnalysis.save_state">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">save_state</span><span class="signature">(self, filename)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">save_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Saves the complete state of the analysis object to a pickle file,</span>
<span class="sd">        except the sampler object (self.samples).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename : string</span>
<span class="sd">            name to the file to write the state to</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Saving analysis state to </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">filename</span><span class="p">)</span>
        <span class="c1"># make a copy of the state, and do not store the sampler as well</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;sampler&#39;</span><span class="p">]</span>
        <span class="n">file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span>
        <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span>
        <span class="n">file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>

        </details>

            <div class="docstring"><p>Saves the complete state of the analysis object to a pickle file,
except the sampler object (self.samples).</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>filename</strong> (string):
name to the file to write the state to</li>
</ul>
</div>


                            </div>
                            <div id="SCAnalysis.load_state" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SCAnalysis.load_state">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">load_state</span><span class="signature">(self, filename)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">load_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Loads the complete state of the analysis object from a</span>
<span class="sd">        pickle file, stored using save_state.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename : string</span>
<span class="sd">            name of the file to load</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Loading analysis state from </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">filename</span><span class="p">)</span>
        <span class="n">file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">state</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="n">file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>

        </details>

            <div class="docstring"><p>Loads the complete state of the analysis object from a
pickle file, stored using save_state.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>filename</strong> (string):
name of the file to load</li>
</ul>
</div>


                            </div>
                            <div id="SCAnalysis.analyse" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SCAnalysis.analyse">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">analyse</span><span class="signature">(self, data_frame=None, compute_moments=True, compute_Sobols=True)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">analyse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_frame</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">compute_moments</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">compute_Sobols</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform SC analysis on input `data_frame`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data_frame : pandas.DataFrame</span>
<span class="sd">            Input data for analysis.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Results dictionary with sub-dicts with keys:</span>
<span class="sd">            [&#39;statistical_moments&#39;, &#39;sobol_indices&#39;].</span>
<span class="sd">            Each dict has an entry for each item in `qoi_cols`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">data_frame</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Analysis element needs a data frame to &quot;</span>
                               <span class="s2">&quot;analyse&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_frame</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="ow">and</span> <span class="n">data_frame</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;No data in data frame passed to analyse element&quot;</span><span class="p">)</span>

        <span class="c1"># the number of uncertain parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">N</span>
        <span class="c1"># tensor grid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xi_d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">xi_d</span>
        <span class="c1"># the maximum level (quad order) of the (sparse) grid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">L</span>

        <span class="c1"># if L &lt; L_min: quadratures and interpolations are zero</span>
        <span class="c1"># For full tensor grid: there is only one level: L_min = L</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">L_min</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">polynomial_order</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">l_norm_min</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span>
        <span class="c1"># For sparse grid: one or more levels</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">L_min</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="c1"># multi indices (stored in l_norm) for isotropic sparse grid or</span>
            <span class="c1"># dimension-adaptive grid before the 1st refinement.</span>
            <span class="c1"># If dimension_adaptive and nadaptations &gt; 0: l_norm</span>
            <span class="c1"># is computed in self.adaptation_metric</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension_adaptive</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">nadaptations</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># the maximum level (quad order) of the (sparse) grid</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">compute_sparse_multi_idx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">l_norm_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="c1"># #compute generalized combination coefficients</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comb_coef</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_comb_coef</span><span class="p">()</span>

        <span class="c1"># 1d weights and points per level</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xi_1d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">xi_1d</span>
        <span class="c1"># self.wi_1d = self.compute_SC_weights(rule=self.sampler.quad_rule)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wi_1d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">wi_1d</span>

        <span class="c1"># Extract output values for each quantity of interest from Dataframe</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Loading samples...&#39;</span><span class="p">)</span>
        <span class="n">qoi_cols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qoi_cols</span>
        <span class="n">samples</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">qoi_cols</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">run_id</span> <span class="ow">in</span> <span class="n">data_frame</span><span class="p">[(</span><span class="s1">&#39;run_id&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span><span class="o">.</span><span class="n">unique</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">qoi_cols</span><span class="p">:</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">data_frame</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">data_frame</span><span class="p">[(</span><span class="s1">&#39;run_id&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">==</span> <span class="n">run_id</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
                <span class="n">samples</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">samples</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;done&#39;</span><span class="p">)</span>

        <span class="c1"># size of one code sample</span>
        <span class="c1"># TODO: change this to include QoI of different size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N_qoi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">qoi_cols</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span>

        <span class="c1"># assume that self.l_norm has changed, and that the interpolation</span>
        <span class="c1"># must be initialised, see sc_expansion subroutine</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_interpolation</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># TODO: same pce coefs must be computed for every qoi</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pce_coefs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SC2PCE</span><span class="p">(</span><span class="n">samples</span><span class="p">[</span><span class="n">qoi_cols</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>

        <span class="c1"># Compute descriptive statistics for each quantity of interest</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;statistical_moments&#39;</span><span class="p">:</span> <span class="p">{},</span>
                   <span class="s1">&#39;sobols_first&#39;</span><span class="p">:</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="p">{}</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">qoi_cols</span><span class="p">},</span>
                   <span class="s1">&#39;sobols&#39;</span><span class="p">:</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="p">{}</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">qoi_cols</span><span class="p">}}</span>

        <span class="k">if</span> <span class="n">compute_moments</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">qoi_k</span> <span class="ow">in</span> <span class="n">qoi_cols</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse</span><span class="p">:</span>
                    <span class="n">mean_k</span><span class="p">,</span> <span class="n">var_k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_moments</span><span class="p">(</span><span class="n">qoi_k</span><span class="p">)</span>
                    <span class="n">std_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">var_k</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">pce_coefs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SC2PCE</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">qoi_k</span><span class="p">])</span>
                    <span class="n">mean_k</span><span class="p">,</span> <span class="n">var_k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pce_stats</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span><span class="p">,</span> <span class="n">pce_coefs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comb_coef</span><span class="p">)</span>
                    <span class="n">std_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">var_k</span><span class="p">)</span>

                <span class="c1"># compute statistical moments</span>
                <span class="n">results</span><span class="p">[</span><span class="s1">&#39;statistical_moments&#39;</span><span class="p">][</span><span class="n">qoi_k</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;mean&#39;</span><span class="p">:</span> <span class="n">mean_k</span><span class="p">,</span>
                                                         <span class="s1">&#39;var&#39;</span><span class="p">:</span> <span class="n">var_k</span><span class="p">,</span>
                                                         <span class="s1">&#39;std&#39;</span><span class="p">:</span> <span class="n">std_k</span><span class="p">}</span>

        <span class="k">if</span> <span class="n">compute_Sobols</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">qoi_k</span> <span class="ow">in</span> <span class="n">qoi_cols</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse</span><span class="p">:</span>
                    <span class="n">results</span><span class="p">[</span><span class="s1">&#39;sobols&#39;</span><span class="p">][</span><span class="n">qoi_k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sobol_indices</span><span class="p">(</span><span class="n">qoi_k</span><span class="p">,</span> <span class="s1">&#39;first_order&#39;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;sobols&#39;</span><span class="p">][</span><span class="n">qoi_k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pce_sobol_indices</span><span class="p">(</span>
                        <span class="n">qoi_k</span><span class="p">,</span> <span class="s1">&#39;first_order&#39;</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">param_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">vary</span><span class="o">.</span><span class="n">get_keys</span><span class="p">()):</span>
                    <span class="n">results</span><span class="p">[</span><span class="s1">&#39;sobols_first&#39;</span><span class="p">][</span><span class="n">qoi_k</span><span class="p">][</span><span class="n">param_name</span><span class="p">]</span> <span class="o">=</span> \
                        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;sobols&#39;</span><span class="p">][</span><span class="n">qoi_k</span><span class="p">][(</span><span class="n">idx</span><span class="p">,)]</span>

        <span class="n">results</span> <span class="o">=</span> <span class="n">SCAnalysisResults</span><span class="p">(</span><span class="n">raw_data</span><span class="o">=</span><span class="n">results</span><span class="p">,</span> <span class="n">samples</span><span class="o">=</span><span class="n">data_frame</span><span class="p">,</span>
                                    <span class="n">qois</span><span class="o">=</span><span class="n">qoi_cols</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">vary</span><span class="o">.</span><span class="n">get_keys</span><span class="p">()))</span>
        <span class="n">results</span><span class="o">.</span><span class="n">surrogate_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surrogate</span>
        <span class="k">return</span> <span class="n">results</span>
</pre></div>

        </details>

            <div class="docstring"><p>Perform SC analysis on input <code>data_frame</code>.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>data_frame</strong> (pandas.DataFrame):
Input data for analysis.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>dict</strong>: Results dictionary with sub-dicts with keys:
['statistical_moments', 'sobol_indices'].
Each dict has an entry for each item in <code>qoi_cols</code>.</li>
</ul>
</div>


                            </div>
                            <div id="SCAnalysis.compute_comb_coef" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SCAnalysis.compute_comb_coef">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">compute_comb_coef</span><span class="signature">(self, **kwargs)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">compute_comb_coef</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute general combination coefficients. These are the coefficients</span>
<span class="sd">        multiplying the tensor products associated to each multi index l,</span>
<span class="sd">        see page 12 Gerstner &amp; Griebel, numerical integration using sparse grids</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s1">&#39;l_norm&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">l_norm</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;l_norm&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">l_norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span>

        <span class="n">comb_coef</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Computing combination coefficients...&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">l_norm</span><span class="p">:</span>
            <span class="n">coef</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="c1"># for every k, subtract all multi indices</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">l_norm</span><span class="p">:</span>
                <span class="n">z</span> <span class="o">=</span> <span class="n">l</span> <span class="o">-</span> <span class="n">k</span>
                <span class="c1"># if the results contains only 0&#39;s and 1&#39;s, then z is the</span>
                <span class="c1"># vector that can be formed from a tensor product of unit vectors</span>
                <span class="c1"># for which k+z is in self.l_norm</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">z</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)):</span>
                    <span class="n">coef</span> <span class="o">+=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">z</span><span class="p">))</span>
            <span class="n">comb_coef</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span> <span class="o">=</span> <span class="n">coef</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;done&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">comb_coef</span>
</pre></div>

        </details>

            <div class="docstring"><p>Compute general combination coefficients. These are the coefficients
multiplying the tensor products associated to each multi index l,
see page 12 Gerstner &amp; Griebel, numerical integration using sparse grids</p>
</div>


                            </div>
                            <div id="SCAnalysis.adapt_dimension" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SCAnalysis.adapt_dimension">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">adapt_dimension</span><span class="signature">(
    self,
    qoi,
    data_frame,
    store_stats_history=True,
    method=&#39;surplus&#39;,
    **kwargs
)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">adapt_dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qoi</span><span class="p">,</span> <span class="n">data_frame</span><span class="p">,</span> <span class="n">store_stats_history</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">method</span><span class="o">=</span><span class="s1">&#39;surplus&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the adaptation metric and decide which of the admissible</span>
<span class="sd">        level indices to include in next iteration of the sparse grid. The</span>
<span class="sd">        adaptation metric is based on the hierarchical surplus, defined as the</span>
<span class="sd">        difference between the new code values of the admissible level indices,</span>
<span class="sd">        and the SC surrogate of the previous iteration. Alternatively, it can be</span>
<span class="sd">        based on the difference between the output mean of the current level,</span>
<span class="sd">        and the mean computed with one extra admissible index.</span>

<span class="sd">        This subroutine must be called AFTER the code is evaluated at</span>
<span class="sd">        the new points, but BEFORE the analysis is performed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        qoi : string</span>
<span class="sd">            the name of the quantity of interest which is used</span>
<span class="sd">            to base the adaptation metric on.</span>
<span class="sd">        data_frame : pandas.DataFrame</span>
<span class="sd">        store_stats_history : bool</span>
<span class="sd">            store the mean and variance at each refinement in self.mean_history</span>
<span class="sd">            and self.std_history. Used for checking convergence in the statistics</span>
<span class="sd">            over the refinement iterations</span>
<span class="sd">        method : string</span>
<span class="sd">            name of the refinement error, default is &#39;surplus&#39;. In this case the</span>
<span class="sd">            error is based on the hierarchical surplus, which is an interpolation</span>
<span class="sd">            based error. Another possibility is &#39;var&#39;,</span>
<span class="sd">            in which case the error is based on the difference in the </span>
<span class="sd">            variance between the current estimate and the estimate obtained</span>
<span class="sd">            when a particular candidate direction is added.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Refining sampling plan...&#39;</span><span class="p">)</span>
        <span class="c1"># load the code samples</span>
        <span class="n">samples</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_frame</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">run_id</span> <span class="ow">in</span> <span class="n">data_frame</span><span class="p">[(</span><span class="s1">&#39;run_id&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span><span class="o">.</span><span class="n">unique</span><span class="p">():</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">data_frame</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">data_frame</span><span class="p">[(</span><span class="s1">&#39;run_id&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">==</span> <span class="n">run_id</span><span class="p">][</span><span class="n">qoi</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
                <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;var&#39;</span><span class="p">:</span>
            <span class="n">all_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">admissible_idx</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xi_1d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">xi_1d</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wi_1d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">wi_1d</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pce_coefs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SC2PCE</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">l_norm</span><span class="o">=</span><span class="n">all_idx</span><span class="p">,</span>
                                         <span class="n">xi_d</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">xi_d</span><span class="p">)</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">var_l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pce_stats</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pce_coefs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comb_coef</span><span class="p">)</span>

        <span class="c1"># the currently accepted grid points</span>
        <span class="n">xi_d_accepted</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">generate_grid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span><span class="p">)</span>

        <span class="c1"># compute the hierarchical surplus based error for every admissible l</span>
        <span class="n">error</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">admissible_idx</span><span class="p">:</span>
            <span class="n">error</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># compute the error based on the hierarchical surplus (interpolation based)</span>
            <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;surplus&#39;</span><span class="p">:</span>
                <span class="c1"># collocation points of current level index l</span>
                <span class="n">X_l</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">xi_1d</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">l</span><span class="p">[</span><span class="n">n</span><span class="p">]]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)]</span>
                <span class="n">X_l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">X_l</span><span class="p">)))</span>
                <span class="c1"># only consider new points, subtract the accepted points</span>
                <span class="n">X_l</span> <span class="o">=</span> <span class="n">setdiff2d</span><span class="p">(</span><span class="n">X_l</span><span class="p">,</span> <span class="n">xi_d_accepted</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="n">X_l</span><span class="p">:</span>
                    <span class="c1"># find the location of the current xi in the global grid</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">xi</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">xi_d</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="c1"># hierarchical surplus error at xi</span>
                    <span class="n">hier_surplus</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">surrogate</span><span class="p">(</span><span class="n">qoi</span><span class="p">,</span> <span class="n">xi</span><span class="p">)</span>
                    <span class="k">if</span> <span class="s1">&#39;index&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                        <span class="n">hier_surplus</span> <span class="o">=</span> <span class="n">hier_surplus</span><span class="p">[</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">]]</span>
                        <span class="n">error</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">hier_surplus</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">error</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">hier_surplus</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">))</span>
                <span class="c1"># compute mean error over all points in X_l</span>
                <span class="n">error</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">error</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)])</span>
            <span class="c1"># compute the error based on quadrature of the variance</span>
            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;var&#39;</span><span class="p">:</span>
                <span class="c1"># create a candidate set of multi indices by adding the current</span>
                <span class="c1"># admissible index to l_norm</span>
                <span class="n">candidate_l_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span><span class="p">,</span> <span class="n">l</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">])))</span>
                <span class="c1"># now we must recompute the combination coefficients</span>
                <span class="n">c_l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_comb_coef</span><span class="p">(</span><span class="n">l_norm</span><span class="o">=</span><span class="n">candidate_l_norm</span><span class="p">)</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">var_candidate_l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pce_stats</span><span class="p">(</span><span class="n">candidate_l_norm</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pce_coefs</span><span class="p">,</span> <span class="n">c_l</span><span class="p">)</span>
                <span class="c1">#error in var</span>
                <span class="n">error</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">var_candidate_l</span> <span class="o">-</span> <span class="n">var_l</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Specified refinement method </span><span class="si">%s</span><span class="s1"> not recognized&#39;</span> <span class="o">%</span> <span class="n">method</span><span class="p">)</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Accepted are surplus, mean or var&#39;</span><span class="p">)</span>
                <span class="kn">import</span> <span class="nn">sys</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">error</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="c1"># logging.debug(&quot;Surplus error when l = %s is %s&quot; % (key, error[key]))</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Refinement error for l = </span><span class="si">%s</span><span class="s2"> is </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">error</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span>
        <span class="c1"># find the admissble index with the largest error</span>
        <span class="n">l_star</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">error</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">error</span><span class="o">.</span><span class="n">get</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">])</span>
        <span class="c1"># logging.debug(&#39;Selecting %s for refinement.&#39; % l_star)</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Selecting </span><span class="si">%s</span><span class="s1"> for refinement.&#39;</span> <span class="o">%</span> <span class="n">l_star</span><span class="p">)</span>
        <span class="c1"># add max error to list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adaptation_errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">error</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>

        <span class="c1"># add l_star to the current accepted level indices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span><span class="p">,</span> <span class="n">l_star</span><span class="p">))</span>
        <span class="c1"># if someone executes this function twice for some reason,</span>
        <span class="c1"># remove the duplicate l_star entry. Keep order unaltered</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">idx</span><span class="p">)])</span>

        <span class="c1"># peform the analyse step, but do not compute moments and Sobols</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analyse</span><span class="p">(</span><span class="n">data_frame</span><span class="p">,</span> <span class="n">compute_moments</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">compute_Sobols</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># if True store the mean and variance at eacht iteration of the adaptive</span>
        <span class="c1"># algorithmn</span>
        <span class="k">if</span> <span class="n">store_stats_history</span><span class="p">:</span>
            <span class="c1"># mean_f, var_f = self.get_moments(qoi)</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Storing moments of iteration </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">nadaptations</span><span class="p">)</span>
            <span class="n">pce_coefs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SC2PCE</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">mean_f</span><span class="p">,</span> <span class="n">var_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pce_stats</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span><span class="p">,</span> <span class="n">pce_coefs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comb_coef</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mean_history</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mean_f</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">std_history</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var_f</span><span class="p">)</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;done&#39;</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Compute the adaptation metric and decide which of the admissible
level indices to include in next iteration of the sparse grid. The
adaptation metric is based on the hierarchical surplus, defined as the
difference between the new code values of the admissible level indices,
and the SC surrogate of the previous iteration. Alternatively, it can be
based on the difference between the output mean of the current level,
and the mean computed with one extra admissible index.</p>

<p>This subroutine must be called AFTER the code is evaluated at
the new points, but BEFORE the analysis is performed.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>qoi</strong> (string):
the name of the quantity of interest which is used
to base the adaptation metric on.</li>
<li><p><strong>data_frame</strong> (pandas.DataFrame):</p></li>
<li><p><strong>store_stats_history</strong> (bool):
store the mean and variance at each refinement in self.mean_history
and self.std_history. Used for checking convergence in the statistics
over the refinement iterations</p></li>
<li><strong>method</strong> (string):
name of the refinement error, default is 'surplus'. In this case the
error is based on the hierarchical surplus, which is an interpolation
based error. Another possibility is 'var',
in which case the error is based on the difference in the 
variance between the current estimate and the estimate obtained
when a particular candidate direction is added.</li>
</ul>
</div>


                            </div>
                            <div id="SCAnalysis.merge_accepted_and_admissible" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SCAnalysis.merge_accepted_and_admissible">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">merge_accepted_and_admissible</span><span class="signature">(self, level=0, **kwargs)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">merge_accepted_and_admissible</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;In the case of the dimension-adaptive sampler, there are 2 sets of</span>
<span class="sd">        quadrature multi indices. There are the accepted indices that are actually</span>
<span class="sd">        used in the analysis, and the admissible indices, of which some might</span>
<span class="sd">        move to the accepted set in subsequent iterations. This subroutine merges</span>
<span class="sd">        the two sets of multi indices by moving all admissible to the set of</span>
<span class="sd">        accepted indices.</span>
<span class="sd">        Do this at the end, when no more refinements will be executed. The</span>
<span class="sd">        samples related to the admissble indices are already computed, although</span>
<span class="sd">        not used in the analysis. By executing this subroutine at very end, all</span>
<span class="sd">        computed samples are used during the final postprocessing stage. Execute</span>
<span class="sd">        campaign.apply_analysis to let the new set of indices take effect.</span>
<span class="sd">        If further refinements are executed after all via sampler.look_ahead, the</span>
<span class="sd">        number of new admissible samples to be computed can be very high,</span>
<span class="sd">        especially in high dimensions. It is possible to undo the merge via</span>
<span class="sd">        analysis.undo_merge before new refinements are made. Execute</span>
<span class="sd">        campaign.apply_analysis again to let the old set of indices take effect.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s1">&#39;include&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">include</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;include&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">include</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">dimension_adaptive</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Moving admissible indices to the accepted set...&#39;</span><span class="p">)</span>
            <span class="c1"># make a backup of l_norm, such that undo_merge can revert back</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">l_norm_backup</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span><span class="p">)</span>
            <span class="c1"># merge admissible and accepted multi indices</span>
            <span class="k">if</span> <span class="n">level</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">merged_l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">admissible_idx</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">admissible_idx</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">admissible_idx</span><span class="p">:</span>
                    <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">l</span> <span class="o">==</span> <span class="n">L</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">L</span> <span class="o">&lt;=</span> <span class="n">level</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">include</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="n">admissible_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
                        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">admissible_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">admissible_idx</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">count</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">])</span>
                <span class="n">merged_l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span><span class="p">,</span> <span class="n">admissible_idx</span><span class="p">))</span>
            <span class="c1"># make sure final result contains only unique indices and store</span>
            <span class="c1">#results in l_norm</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">merged_l</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># return np.array([merged_l[i] for i in sorted(idx)])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">merged_l</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">idx</span><span class="p">)])</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;done&#39;</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>In the case of the dimension-adaptive sampler, there are 2 sets of
quadrature multi indices. There are the accepted indices that are actually
used in the analysis, and the admissible indices, of which some might
move to the accepted set in subsequent iterations. This subroutine merges
the two sets of multi indices by moving all admissible to the set of
accepted indices.
Do this at the end, when no more refinements will be executed. The
samples related to the admissble indices are already computed, although
not used in the analysis. By executing this subroutine at very end, all
computed samples are used during the final postprocessing stage. Execute
campaign.apply_analysis to let the new set of indices take effect.
If further refinements are executed after all via sampler.look_ahead, the
number of new admissible samples to be computed can be very high,
especially in high dimensions. It is possible to undo the merge via
analysis.undo_merge before new refinements are made. Execute
campaign.apply_analysis again to let the old set of indices take effect.</p>
</div>


                            </div>
                            <div id="SCAnalysis.undo_merge" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SCAnalysis.undo_merge">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">undo_merge</span><span class="signature">(self)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">undo_merge</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This reverses the effect of the merge_accepted_and_admissble subroutine.</span>
<span class="sd">        Execute if further refinement are required after all.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">dimension_adaptive</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">l_norm_backup</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Restored old multi indices.&#39;</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This reverses the effect of the merge_accepted_and_admissble subroutine.
Execute if further refinement are required after all.</p>
</div>


                            </div>
                            <div id="SCAnalysis.get_adaptation_errors" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SCAnalysis.get_adaptation_errors">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_adaptation_errors</span><span class="signature">(self)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_adaptation_errors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns self.adaptation_errors</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">adaptation_errors</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns self.adaptation_errors</p>
</div>


                            </div>
                            <div id="SCAnalysis.plot_stat_convergence" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SCAnalysis.plot_stat_convergence">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">plot_stat_convergence</span><span class="signature">(self)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">plot_stat_convergence</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plots the convergence of the statistical mean and std dev over the different</span>
<span class="sd">        refinements in a dimension-adaptive setting. Specifically the inf norm</span>
<span class="sd">        of the difference between the stats of iteration i and iteration i-1</span>
<span class="sd">        is plotted.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension_adaptive</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Only works for the dimension adaptive sampler.&#39;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="n">K</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mean_history</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">K</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Means from at least two refinements are required&#39;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">differ_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">K</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">differ_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">K</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">K</span><span class="p">):</span>
                <span class="n">differ_mean</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mean_history</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span>
                                                    <span class="bp">self</span><span class="o">.</span><span class="n">mean_history</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
                <span class="c1"># make relative</span>
                <span class="n">differ_mean</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">differ_mean</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mean_history</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span>
                                                                         <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>

                <span class="n">differ_std</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">std_history</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span>
                                                   <span class="bp">self</span><span class="o">.</span><span class="n">std_history</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
                <span class="c1"># make relative</span>
                <span class="n">differ_std</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">differ_std</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">std_history</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span>
                                                                       <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>

        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="s1">&#39;stat_conv&#39;</span><span class="p">)</span>
        <span class="n">ax1</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;moment convergence&#39;</span><span class="p">)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;iteration&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
        <span class="c1"># ax1.set_ylabel(r&#39;$ ||\mathrm{mean}_i - \mathrm{mean}_{i - 1}||_\infty$&#39;,</span>
        <span class="c1"># color=&#39;r&#39;, fontsize=12)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;relative error mean&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">K</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">differ_mean</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;+&#39;</span><span class="p">)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">labelcolor</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>

        <span class="n">ax2</span> <span class="o">=</span> <span class="n">ax1</span><span class="o">.</span><span class="n">twinx</span><span class="p">()</span>  <span class="c1"># instantiate a second axes that shares the same x-axis</span>

        <span class="c1"># ax2.set_ylabel(r&#39;$ ||\mathrm{var}_i - \mathrm{var}_{i - 1}||_\infty$&#39;,</span>
        <span class="c1"># color=&#39;b&#39;, fontsize=12)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;relative error variance&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">K</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">differ_std</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;*&#39;</span><span class="p">)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">labelcolor</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>

        </details>

            <div class="docstring"><p>Plots the convergence of the statistical mean and std dev over the different
refinements in a dimension-adaptive setting. Specifically the inf norm
of the difference between the stats of iteration i and iteration i-1
is plotted.</p>
</div>


                            </div>
                            <div id="SCAnalysis.surrogate" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SCAnalysis.surrogate">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">surrogate</span><span class="signature">(self, qoi, x, L=None)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">surrogate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qoi</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">L</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Use sc_expansion UQP as a surrogate</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        qoi : str</span>
<span class="sd">            name of the qoi</span>
<span class="sd">        x : array</span>
<span class="sd">            location at which to evaluate the surrogate</span>
<span class="sd">        L : int</span>
<span class="sd">            level of the (sparse) grid, default = self.L</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        the interpolated value of qoi at x (float, (N_qoi,))</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc_expansion</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">qoi</span><span class="p">],</span> <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Use sc_expansion UQP as a surrogate</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>qoi</strong> (str):
name of the qoi</li>
<li><strong>x</strong> (array):
location at which to evaluate the surrogate</li>
<li><strong>L</strong> (int):
level of the (sparse) grid, default = self.L</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>the interpolated value of qoi at x (float, (N_qoi,))</strong></li>
</ul>
</div>


                            </div>
                            <div id="SCAnalysis.quadrature" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SCAnalysis.quadrature">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">quadrature</span><span class="signature">(self, qoi, samples=None)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">quadrature</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qoi</span><span class="p">,</span> <span class="n">samples</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes a (Smolyak) quadrature</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        qoi : str</span>
<span class="sd">            name of the qoi</span>

<span class="sd">        samples: array</span>
<span class="sd">            compute the mean by setting samples = self.samples.</span>
<span class="sd">            To compute the variance, set samples = (self.samples - mean)**2</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        the quadrature of qoi</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">samples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">qoi</span><span class="p">]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">combination_technique</span><span class="p">(</span><span class="n">qoi</span><span class="p">,</span> <span class="n">samples</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Computes a (Smolyak) quadrature</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>qoi</strong> (str):
name of the qoi</li>
<li><strong>samples</strong> (array):
compute the mean by setting samples = self.samples.
To compute the variance, set samples = (self.samples - mean)**2</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>the quadrature of qoi</strong></li>
</ul>
</div>


                            </div>
                            <div id="SCAnalysis.combination_technique" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SCAnalysis.combination_technique">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">combination_technique</span><span class="signature">(self, qoi, samples=None, **kwargs)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">combination_technique</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qoi</span><span class="p">,</span> <span class="n">samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Efficient quadrature formulation for (sparse) grids. See:</span>

<span class="sd">            Gerstner, Griebel, &quot;Numerical integration using sparse grids&quot;</span>
<span class="sd">            Uses the general combination technique (page 12).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        qoi : str</span>
<span class="sd">            name of the qoi</span>

<span class="sd">        samples : array</span>
<span class="sd">            compute the mean by setting samples = self.samples.</span>
<span class="sd">            To compute the variance, set samples = (self.samples - mean)**2</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">samples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">qoi</span><span class="p">]</span>

        <span class="c1"># In the case of quadrature-based refinement, we need to specify</span>
        <span class="c1"># l_norm, comb_coef and xi_d other than the current defualt values</span>
        <span class="k">if</span> <span class="s1">&#39;l_norm&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">l_norm</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;l_norm&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">l_norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span>

        <span class="k">if</span> <span class="s1">&#39;comb_coef&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">comb_coef</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;comb_coef&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">comb_coef</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comb_coef</span>

        <span class="k">if</span> <span class="s1">&#39;xi_d&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">xi_d</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;xi_d&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xi_d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi_d</span>

        <span class="c1"># quadrature Q</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="c1"># loop over l</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">l_norm</span><span class="p">:</span>
            <span class="c1"># compute the tensor product of parameter and weight values</span>
            <span class="n">X_k</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">xi_1d</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">l</span><span class="p">[</span><span class="n">n</span><span class="p">]]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)]</span>
            <span class="n">W_k</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">wi_1d</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">l</span><span class="p">[</span><span class="n">n</span><span class="p">]]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)]</span>

            <span class="n">X_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">X_k</span><span class="p">)))</span>
            <span class="n">W_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">W_k</span><span class="p">)))</span>
            <span class="n">W_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">W_k</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">W_k</span> <span class="o">=</span> <span class="n">W_k</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">W_k</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">])</span>

            <span class="c1"># scaling factor of combination technique</span>
            <span class="n">W_k</span> <span class="o">=</span> <span class="n">W_k</span> <span class="o">*</span> <span class="n">comb_coef</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span>

            <span class="c1"># find corresponding code values</span>
            <span class="n">f_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">samples</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">x</span> <span class="o">==</span> <span class="n">xi_d</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">X_k</span><span class="p">])</span>

            <span class="c1"># quadrature of Q^1_{k1} X ... X Q^1_{kN} product</span>
            <span class="n">Q</span> <span class="o">=</span> <span class="n">Q</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">f_k</span> <span class="o">*</span> <span class="n">W_k</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="k">return</span> <span class="n">Q</span>
</pre></div>

        </details>

            <div class="docstring"><p>Efficient quadrature formulation for (sparse) grids. See:</p>

<pre><code>Gerstner, Griebel, "Numerical integration using sparse grids"
Uses the general combination technique (page 12).
</code></pre>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>qoi</strong> (str):
name of the qoi</li>
<li><strong>samples</strong> (array):
compute the mean by setting samples = self.samples.
To compute the variance, set samples = (self.samples - mean)**2</li>
</ul>
</div>


                            </div>
                            <div id="SCAnalysis.get_moments" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SCAnalysis.get_moments">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_moments</span><span class="signature">(self, qoi)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_moments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qoi</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        qoi : str</span>
<span class="sd">            name of the qoi</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mean and variance of qoi (float (N_qoi,))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Computing moments...&#39;</span><span class="p">)</span>
        <span class="c1"># compute mean</span>
        <span class="n">mean_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">quadrature</span><span class="p">(</span><span class="n">qoi</span><span class="p">)</span>
        <span class="c1"># compute variance</span>
        <span class="n">variance_samples</span> <span class="o">=</span> <span class="p">[(</span><span class="n">sample</span> <span class="o">-</span> <span class="n">mean_f</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">sample</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">qoi</span><span class="p">]]</span>
        <span class="n">var_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">quadrature</span><span class="p">(</span><span class="n">qoi</span><span class="p">,</span> <span class="n">samples</span><span class="o">=</span><span class="n">variance_samples</span><span class="p">)</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;done&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mean_f</span><span class="p">,</span> <span class="n">var_f</span>
</pre></div>

        </details>

            <div class="docstring"><h6 id="parameters">Parameters</h6>

<ul>
<li><strong>qoi</strong> (str):
name of the qoi</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>mean and variance of qoi (float (N_qoi,))</strong></li>
</ul>
</div>


                            </div>
                            <div id="SCAnalysis.sc_expansion" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SCAnalysis.sc_expansion">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">sc_expansion</span><span class="signature">(self, samples, x)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">sc_expansion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">samples</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Non recursive implementation of the SC expansion. Performs interpolation</span>
<span class="sd">        of code output samples for both full and sparse grids.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        samples : list</span>
<span class="sd">            list of code output samples.</span>
<span class="sd">        x : array</span>
<span class="sd">            One or more locations in stochastic space at which to evaluate</span>
<span class="sd">            the surrogate.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        surr : array</span>
<span class="sd">            The interpolated values of the code output at input locations</span>
<span class="sd">            specified by x.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Computing the tensor grid of each multiindex l (xi_d below)</span>
        <span class="c1"># every time is slow. Instead store it globally, and only recompute when</span>
        <span class="c1"># self.l_norm has changed, when the flag init_interpolation = True.</span>
        <span class="c1"># This flag is set to True when self.analyse is executed</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_interpolation</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xi_d_per_l</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span><span class="p">:</span>
                <span class="c1"># all points corresponding to l</span>
                <span class="n">xi</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">xi_1d</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">l</span><span class="p">[</span><span class="n">n</span><span class="p">]]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">xi_d_per_l</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">xi</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">init_interpolation</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">surr</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span><span class="p">:</span>
            <span class="c1"># all points corresponding to l</span>
            <span class="c1"># xi = [self.xi_1d[n][l[n]] for n in range(self.N)]</span>
            <span class="c1"># xi_d = np.array(list(product(*xi)))</span>
            <span class="n">xi_d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi_d_per_l</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span>

            <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="n">xi_d</span><span class="p">:</span>
                <span class="c1"># indices of current collocation point</span>
                <span class="c1"># in corresponding 1d colloc points (self.xi_1d[n][l[n]])</span>
                <span class="c1"># These are the j of the 1D lagrange polynomials l_j(x), see</span>
                <span class="c1"># lagrange_poly subroutine</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi_1d</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">l</span><span class="p">[</span><span class="n">n</span><span class="p">]]</span> <span class="o">==</span> <span class="n">xi</span><span class="p">[</span><span class="n">n</span><span class="p">])</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)]</span>
                <span class="c1"># index of the code sample</span>
                <span class="n">sample_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">xi</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi_d</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

                <span class="c1"># values of Lagrange polynomials at x</span>
                <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">weight</span> <span class="o">=</span> <span class="p">[</span><span class="n">lagrange_poly</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi_1d</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">l</span><span class="p">[</span><span class="n">n</span><span class="p">]],</span> <span class="n">idx</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
                              <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)]</span>
                    <span class="n">surr</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comb_coef</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span> <span class="o">*</span> <span class="n">samples</span><span class="p">[</span><span class="n">sample_idx</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="c1"># batch setting, if multiple x values are presribed</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">weight</span> <span class="o">=</span> <span class="p">[</span><span class="n">lagrange_poly</span><span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="n">n</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi_1d</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">l</span><span class="p">[</span><span class="n">n</span><span class="p">]],</span> <span class="n">idx</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
                              <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)]</span>
                    <span class="n">surr</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comb_coef</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span> <span class="o">*</span> <span class="n">samples</span><span class="p">[</span><span class="n">sample_idx</span><span class="p">]</span> <span class="o">*</span> \
                        <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">surr</span>
</pre></div>

        </details>

            <div class="docstring"><p>Non recursive implementation of the SC expansion. Performs interpolation
of code output samples for both full and sparse grids.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>samples</strong> (list):
list of code output samples.</li>
<li><strong>x</strong> (array):
One or more locations in stochastic space at which to evaluate
the surrogate.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>surr</strong> (array):
The interpolated values of the code output at input locations
specified by x.</li>
</ul>
</div>


                            </div>
                            <div id="SCAnalysis.get_sample_array" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SCAnalysis.get_sample_array">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_sample_array</span><span class="signature">(self, qoi)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_sample_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qoi</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        qoi : str</span>
<span class="sd">            name of quantity of interest</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        array of all samples of qoi</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">qoi</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">qoi</span><span class="p">]))])</span>
</pre></div>

        </details>

            <div class="docstring"><h6 id="parameters">Parameters</h6>

<ul>
<li><strong>qoi</strong> (str):
name of quantity of interest</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>array of all samples of qoi</strong></li>
</ul>
</div>


                            </div>
                            <div id="SCAnalysis.adaptation_histogram" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SCAnalysis.adaptation_histogram">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">adaptation_histogram</span><span class="signature">(self)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">adaptation_histogram</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plots a bar chart of the maximum order of the quadrature rule</span>
<span class="sd">        that is used in each dimension. Use in case of the dimension adaptive</span>
<span class="sd">        sampler to get an idea of which parameters were more refined than others.</span>
<span class="sd">        This gives only a first-order idea, as it only plots the max quad</span>
<span class="sd">        order independently per input parameter, so higher-order refinements</span>
<span class="sd">        that were made do not show up in the bar chart.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="s1">&#39;adapt_hist&#39;</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">])</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="s1">&#39;max quadrature order&#39;</span><span class="p">,</span>
                             <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Number of refinements = </span><span class="si">%d</span><span class="s1">&#39;</span>
                             <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">nadaptations</span><span class="p">)</span>
        <span class="c1"># find max quad order for every parameter</span>
        <span class="n">adapt_measure</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">adapt_measure</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="n">height</span><span class="o">=</span><span class="n">adapt_measure</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">params</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">vary</span><span class="o">.</span><span class="n">get_keys</span><span class="p">())</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">adapt_measure</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">rotation</span><span class="o">=</span><span class="mi">90</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>

        </details>

            <div class="docstring"><p>Plots a bar chart of the maximum order of the quadrature rule
that is used in each dimension. Use in case of the dimension adaptive
sampler to get an idea of which parameters were more refined than others.
This gives only a first-order idea, as it only plots the max quad
order independently per input parameter, so higher-order refinements
that were made do not show up in the bar chart.</p>
</div>


                            </div>
                            <div id="SCAnalysis.adaptation_table" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SCAnalysis.adaptation_table">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">adaptation_table</span><span class="signature">(self, **kwargs)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">adaptation_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plots a color-coded table of the quadrature-order refinement.</span>
<span class="sd">        Shows in what order the parameters were refined, and unlike</span>
<span class="sd">        adaptation_histogram, this also shows higher-order refinements.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        **kwargs: can contain kwarg &#39;order&#39; to specify the order in which</span>
<span class="sd">        the variables on the x axis are plotted (e.g. in order of decreasing</span>
<span class="sd">        1st order Sobol index).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># if specified, plot the variables on the x axis in a given order</span>
        <span class="k">if</span> <span class="s1">&#39;order&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">order</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;order&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">order</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>

        <span class="n">l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span><span class="p">)[:,</span> <span class="n">order</span><span class="p">]</span>
        <span class="kn">import</span> <span class="nn">matplotlib</span> <span class="k">as</span> <span class="nn">mpl</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">[</span><span class="mi">12</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>

        <span class="c1"># max quad order</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
        <span class="n">cmap</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s1">&#39;Purples&#39;</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
        <span class="c1"># plot &#39;heat map&#39; of refinement</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">)</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span><span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">M</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">sm</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">ScalarMappable</span><span class="p">(</span><span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">)</span>
        <span class="n">sm</span><span class="o">.</span><span class="n">set_array</span><span class="p">([])</span>
        <span class="n">cb</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">sm</span><span class="p">)</span>
        <span class="c1"># plot the quad order in the middle of the colorbar intervals</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">M</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">M</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">tick_p</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">cb</span><span class="o">.</span><span class="n">set_ticks</span><span class="p">(</span><span class="n">tick_p</span><span class="p">)</span>
        <span class="n">cb</span><span class="o">.</span><span class="n">set_ticklabels</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">M</span><span class="p">))</span>
        <span class="n">cb</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;quadrature order&#39;</span><span class="p">)</span>
        <span class="c1"># plot the variables names on the x axis</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">vary</span><span class="o">.</span><span class="n">get_keys</span><span class="p">()))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_yticklabels</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="n">order</span><span class="p">],</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
        <span class="c1"># ax.set_yticks(range(l.shape[0]))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;iteration&#39;</span><span class="p">)</span>
        <span class="c1"># plt.yticks(rotation=90)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>

        </details>

            <div class="docstring"><p>Plots a color-coded table of the quadrature-order refinement.
Shows in what order the parameters were refined, and unlike
adaptation_histogram, this also shows higher-order refinements.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><p><strong>**kwargs</strong> (can contain kwarg 'order' to specify the order in which):</p></li>
<li><p><strong>the variables on the x axis are plotted (e.g. in order of decreasing</strong></p></li>
<li><strong>1st order Sobol index).</strong></li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>None.</strong></li>
</ul>
</div>


                            </div>
                            <div id="SCAnalysis.plot_grid" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SCAnalysis.plot_grid">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">plot_grid</span><span class="signature">(self)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">plot_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plots the collocation points for 2 and 3 dimensional problems</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">xlabel</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;$x_1$&#39;</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;$x_2$&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi_d</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi_d</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;ro&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">mpl_toolkits.mplot3d</span> <span class="kn">import</span> <span class="n">Axes3D</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">,</span> <span class="n">xlabel</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;$x_1$&#39;</span><span class="p">,</span>
                                 <span class="n">ylabel</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;$x_2$&#39;</span><span class="p">,</span> <span class="n">zlabel</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;$x_3$&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi_d</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi_d</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi_d</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Will only plot for N = 2 or N = 3.&#39;</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Plots the collocation points for 2 and 3 dimensional problems</p>
</div>


                            </div>
                            <div id="SCAnalysis.SC2PCE" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SCAnalysis.SC2PCE">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SC2PCE</span><span class="signature">(self, samples, verbose=True, **kwargs)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SC2PCE</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">samples</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes the Polynomials Chaos Expansion coefficients from the SC</span>
<span class="sd">        expansion via a transformation of basis (Lagrange polynomials basis --&gt;</span>
<span class="sd">        orthonomial basis).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        samples : array</span>
<span class="sd">            SC code samples from which to compute the PCE coefficients</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pce_coefs : dict</span>
<span class="sd">            PCE coefficients per multi index l</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pce_coefs</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="s1">&#39;l_norm&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">l_norm</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;l_norm&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">l_norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span>

        <span class="k">if</span> <span class="s1">&#39;xi_d&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">xi_d</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;xi_d&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xi_d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi_d</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;pce_coefs&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pce_coefs</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">count_l</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">l_norm</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pce_coefs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="c1"># pce coefficients for current multi-index l</span>
                <span class="n">pce_coefs</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span> <span class="o">=</span> <span class="p">{}</span>

                <span class="c1"># 1d points generated by l</span>
                <span class="n">x_1d</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">xi_1d</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">l</span><span class="p">[</span><span class="n">n</span><span class="p">]]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)]</span>
                <span class="c1"># 1d Lagrange polynomials generated by l</span>
                <span class="c1"># EDIT: do not use chaospy for Lagrange, converts lagrange into monomial, requires</span>
                <span class="c1"># Vandermonde matrix inversion to find coefficients, which becomes</span>
                <span class="c1"># very ill conditioned rather quickly. Can no longer use cp.E to compute</span>
                <span class="c1"># integrals, use GQ instead</span>
                <span class="c1"># a_1d = [cp.lagrange_polynomial(sampler.xi_1d[n][l[n]]) for n in range(d)]</span>

                <span class="c1"># N-dimensional grid generated by l</span>
                <span class="n">x_l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">x_1d</span><span class="p">)))</span>

                <span class="c1"># all multi indices of the PCE expansion: k &lt;= l</span>
                <span class="n">k_norm</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">l</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)]))</span>

                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Computing PCE coefficients </span><span class="si">%d</span><span class="s1"> / </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">count_l</span><span class="p">,</span> <span class="n">l_norm</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">k_norm</span><span class="p">:</span>
                    <span class="c1"># product of the PCE basis function or order k - 1 and all</span>
                    <span class="c1"># Lagrange basis functions in a_1d, per dimension</span>
                    <span class="c1">#[[phi_k[0]*a_1d[0]], ..., [phi_k[N-1]*a_1d[N-1]]]</span>

                    <span class="c1"># orthogonal polynomial generated by chaospy</span>
                    <span class="n">phi_k</span> <span class="o">=</span> <span class="p">[</span><span class="n">cp</span><span class="o">.</span><span class="n">expansion</span><span class="o">.</span><span class="n">stieltjes</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                                         <span class="n">dist</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">params_distribution</span><span class="p">[</span><span class="n">n</span><span class="p">],</span>
                                         <span class="n">normed</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)]</span>

                    <span class="c1"># the polynomial order of each integrand phi_k*a_j = (k - 1) + (number of</span>
                    <span class="c1"># colloc. points - 1)</span>
                    <span class="n">orders</span> <span class="o">=</span> <span class="p">[(</span><span class="n">k</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi_1d</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">l</span><span class="p">[</span><span class="n">n</span><span class="p">]]</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)]</span>

                    <span class="c1"># will hold the products of PCE basis functions phi_k and lagrange</span>
                    <span class="c1"># interpolation polynomials a_1d</span>
                    <span class="n">cross_prod</span> <span class="o">=</span> <span class="p">[]</span>

                    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">):</span>
                        <span class="c1"># GQ using n points can exactly integrate polynomials of order 2n-1:</span>
                        <span class="c1"># solve for required number of points n when given order</span>
                        <span class="n">n_quad_points</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">orders</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>

                        <span class="c1"># generate Gaussian quad rule</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">params_distribution</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">cp</span><span class="o">.</span><span class="n">DiscreteUniform</span><span class="p">):</span>
                            <span class="n">xi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi_1d</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">l</span><span class="p">[</span><span class="n">n</span><span class="p">]]</span>
                            <span class="n">wi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wi_1d</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">l</span><span class="p">[</span><span class="n">n</span><span class="p">]]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">xi</span><span class="p">,</span> <span class="n">wi</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">generate_quadrature</span><span class="p">(</span>
                                <span class="n">n_quad_points</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">params_distribution</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">rule</span><span class="o">=</span><span class="s2">&quot;G&quot;</span><span class="p">)</span>
                            <span class="n">xi</span> <span class="o">=</span> <span class="n">xi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                        <span class="c1"># number of colloc points = number of Lagrange polynomials</span>
                        <span class="n">n_lagrange_poly</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi_1d</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">l</span><span class="p">[</span><span class="n">n</span><span class="p">]]</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>

                        <span class="c1"># compute the v coefficients = coefficients of SC2PCE mapping</span>
                        <span class="n">v_coefs_n</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_lagrange_poly</span><span class="p">):</span>
                            <span class="c1"># compute values of Lagrange polys at quadrature points</span>
                            <span class="n">l_j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">lagrange_poly</span><span class="p">(</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi_1d</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">l</span><span class="p">[</span><span class="n">n</span><span class="p">]],</span> <span class="n">j</span><span class="p">)</span>
                                            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">xi</span><span class="o">.</span><span class="n">size</span><span class="p">)])</span>
                            <span class="c1"># each coef is the integral of the lagrange poly times the current</span>
                            <span class="c1"># orthogonal PCE poly</span>
                            <span class="n">v_coefs_n</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">l_j</span> <span class="o">*</span> <span class="n">phi_k</span><span class="p">[</span><span class="n">n</span><span class="p">](</span><span class="n">xi</span><span class="p">)</span> <span class="o">*</span> <span class="n">wi</span><span class="p">))</span>
                        <span class="n">cross_prod</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v_coefs_n</span><span class="p">)</span>

                    <span class="c1"># tensor product of all integrals</span>
                    <span class="n">integrals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">cross_prod</span><span class="p">)))</span>
                    <span class="c1"># multiply over the number of parameters: v_prod = v_k1_j1 * ... * v_kd_jd</span>
                    <span class="n">v_prod</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">integrals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">v_prod</span> <span class="o">=</span> <span class="n">v_prod</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">v_prod</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

                    <span class="c1"># find corresponding code values</span>
                    <span class="n">f_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">samples</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">x</span> <span class="o">==</span> <span class="n">xi_d</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">x_l</span><span class="p">])</span>

                    <span class="c1"># the sum of all code sample * v_{k,j_1} * ... * v_{k,j_N}</span>
                    <span class="c1"># equals the PCE coefficient</span>
                    <span class="n">eta_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">f_k</span> <span class="o">*</span> <span class="n">v_prod</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

                    <span class="n">pce_coefs</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)][</span><span class="nb">tuple</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span> <span class="o">=</span> <span class="n">eta_k</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># pce coefs previously computed, just copy result</span>
                <span class="n">pce_coefs</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pce_coefs</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span>
            <span class="n">count_l</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;done&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pce_coefs</span>
</pre></div>

        </details>

            <div class="docstring"><p>Computes the Polynomials Chaos Expansion coefficients from the SC
expansion via a transformation of basis (Lagrange polynomials basis -->
orthonomial basis).</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>samples</strong> (array):
SC code samples from which to compute the PCE coefficients</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>pce_coefs</strong> (dict):
PCE coefficients per multi index l</li>
</ul>
</div>


                            </div>
                            <div id="SCAnalysis.get_pce_stats" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SCAnalysis.get_pce_stats">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_pce_stats</span><span class="signature">(self, l_norm, pce_coefs, comb_coef)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_pce_stats</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l_norm</span><span class="p">,</span> <span class="n">pce_coefs</span><span class="p">,</span> <span class="n">comb_coef</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the mean and the variance based on the PCE coefficients</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        l_norm : array</span>
<span class="sd">            array of quadrature order multi indices</span>
<span class="sd">        pce_coefs : tuple</span>
<span class="sd">            tuple of PCE coefficients computed by SC2PCE subroutine</span>
<span class="sd">        comb_coef : tuple</span>
<span class="sd">            tuple of combination coefficients computed by compute_comb_coef</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple with mean and variance based on the PCE coefficients</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Compute the PCE mean</span>
        <span class="n">k1</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>
        <span class="n">mean</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">l_norm</span><span class="p">:</span>
            <span class="n">mean</span> <span class="o">=</span> <span class="n">mean</span> <span class="o">+</span> <span class="n">comb_coef</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span> <span class="o">*</span> <span class="n">pce_coefs</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)][</span><span class="n">k1</span><span class="p">]</span>

        <span class="n">D</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">l_norm</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">var_k</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">l_norm</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="k">if</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="ow">in</span> <span class="n">pce_coefs</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">eta_k</span> <span class="o">=</span> <span class="n">pce_coefs</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)][</span><span class="nb">tuple</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span>
                    <span class="n">var_k</span> <span class="o">=</span> <span class="n">var_k</span> <span class="o">+</span> <span class="n">comb_coef</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span> <span class="o">*</span> <span class="n">eta_k</span>
            <span class="n">var_k</span> <span class="o">=</span> <span class="n">var_k</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">D</span> <span class="o">+</span> <span class="n">var_k</span>

        <span class="k">return</span> <span class="n">mean</span><span class="p">,</span> <span class="n">D</span>
</pre></div>

        </details>

            <div class="docstring"><p>Compute the mean and the variance based on the PCE coefficients</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>l_norm</strong> (array):
array of quadrature order multi indices</li>
<li><strong>pce_coefs</strong> (tuple):
tuple of PCE coefficients computed by SC2PCE subroutine</li>
<li><strong>comb_coef</strong> (tuple):
tuple of combination coefficients computed by compute_comb_coef</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>tuple with mean and variance based on the PCE coefficients</strong></li>
</ul>
</div>


                            </div>
                            <div id="SCAnalysis.get_pce_sobol_indices" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SCAnalysis.get_pce_sobol_indices">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_pce_sobol_indices</span><span class="signature">(self, qoi, typ=&#39;first_order&#39;, **kwargs)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_pce_sobol_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qoi</span><span class="p">,</span> <span class="n">typ</span><span class="o">=</span><span class="s1">&#39;first_order&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes Sobol indices using Polynomials Chaos coefficients. These</span>
<span class="sd">        coefficients are computed from the SC expansion via a transformation</span>
<span class="sd">        of basis (SC2PCE subroutine). This works better than computing the</span>
<span class="sd">        Sobol indices directly from the SC expansion in the case of the</span>
<span class="sd">        dimension-adaptive sampler.</span>

<span class="sd">        Method: J.D. Jakeman et al, &quot;Adaptive multi-index collocation</span>
<span class="sd">        for uncertainty quantification and sensitivity analysis&quot;, 2019.</span>
<span class="sd">        (Page 18)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        qoi : str</span>
<span class="sd">            name of the Quantity of Interest for which to compute the indices</span>
<span class="sd">        typ : str</span>
<span class="sd">            Default = &#39;first_order&#39;. &#39;all&#39; is also possible</span>
<span class="sd">        **kwargs : dict</span>
<span class="sd">            if this contains &#39;samples&#39;, use these instead of the SC samples ]</span>
<span class="sd">            in the database</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Tuple</span>
<span class="sd">            Mean: PCE mean</span>
<span class="sd">            Var: PCE variance</span>
<span class="sd">            S_u: PCE Sobol indices, either the first order indices or all indices</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s1">&#39;samples&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;samples&#39;</span><span class="p">]</span>
            <span class="n">N_qoi</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">qoi</span><span class="p">]</span>
            <span class="n">N_qoi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_qoi</span>

        <span class="c1"># compute the PCE coefficients</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pce_coefs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SC2PCE</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>

        <span class="c1"># Compute the PCE mean (not really required)</span>
        <span class="n">k1</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>
        <span class="n">mean</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span><span class="p">:</span>
            <span class="n">mean</span> <span class="o">=</span> <span class="n">mean</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">comb_coef</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pce_coefs</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)][</span><span class="n">k1</span><span class="p">]</span>

        <span class="c1"># dict to hold the variance per multi index k</span>
        <span class="n">var</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># D = total PCE variance</span>
        <span class="n">D</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">var_k</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="k">if</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pce_coefs</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">eta_k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pce_coefs</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)][</span><span class="nb">tuple</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span>
                    <span class="n">var_k</span> <span class="o">=</span> <span class="n">var_k</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">comb_coef</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span> <span class="o">*</span> <span class="n">eta_k</span>
            <span class="n">var</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span> <span class="o">=</span> <span class="n">var_k</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">D</span> <span class="o">+</span> <span class="n">var</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Computing Sobol indices...&#39;</span><span class="p">)</span>
        <span class="c1"># Universe = (0, 1, ..., N - 1)</span>
        <span class="n">U</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>

        <span class="c1"># the powerset of U for either the first order or all Sobol indices</span>
        <span class="k">if</span> <span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;first_order&#39;</span><span class="p">:</span>
            <span class="n">P</span> <span class="o">=</span> <span class="p">[()]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">):</span>
                <span class="n">P</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># all indices u</span>
            <span class="n">P</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">powerset</span><span class="p">(</span><span class="n">U</span><span class="p">))</span>

        <span class="c1"># dict to hold the partial Sobol variances and Sobol indices</span>
        <span class="n">D_u</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">S_u</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">P</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="c1"># complement of u</span>
            <span class="n">u_prime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
            <span class="n">k</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">D_u</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N_qoi</span><span class="p">)</span>
            <span class="n">S_u</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N_qoi</span><span class="p">)</span>

            <span class="c1"># compute the set of multi indices corresponding to varying ONLY</span>
            <span class="c1"># the inputs indexed by u</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span><span class="p">:</span>
                <span class="c1"># assume l_i = 1 for all i in u&#39; until found otherwise</span>
                <span class="n">all_ones</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">for</span> <span class="n">i_up</span> <span class="ow">in</span> <span class="n">u_prime</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">l</span><span class="p">[</span><span class="n">i_up</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">all_ones</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">break</span>
                <span class="c1"># if l_i = 1 for all i in u&#39;</span>
                <span class="k">if</span> <span class="n">all_ones</span><span class="p">:</span>
                    <span class="c1"># assume all l_i for i in u are &gt; 1</span>
                    <span class="n">all_gt_one</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">for</span> <span class="n">i_u</span> <span class="ow">in</span> <span class="n">u</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">l</span><span class="p">[</span><span class="n">i_u</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">all_gt_one</span> <span class="o">=</span> <span class="kc">False</span>
                            <span class="k">break</span>
                    <span class="c1"># if both conditions above are True, the current l varies</span>
                    <span class="c1"># only inputs indexed by u, add this l to k</span>
                    <span class="k">if</span> <span class="n">all_gt_one</span><span class="p">:</span>
                        <span class="n">k</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>

            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Multi indices of dimension  </span><span class="si">%s</span><span class="s1"> are </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span>
            <span class="c1"># the partial variance of u is the sum of all variances index by k</span>
            <span class="k">for</span> <span class="n">k_u</span> <span class="ow">in</span> <span class="n">k</span><span class="p">:</span>
                <span class="n">D_u</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">D_u</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">var</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">k_u</span><span class="p">)]</span>

            <span class="c1"># normalize D_u by total variance D to get the Sobol index</span>
            <span class="n">S_u</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">D_u</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">/</span> <span class="n">D</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;done&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mean</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">D_u</span><span class="p">,</span> <span class="n">S_u</span>
</pre></div>

        </details>

            <div class="docstring"><p>Computes Sobol indices using Polynomials Chaos coefficients. These
coefficients are computed from the SC expansion via a transformation
of basis (SC2PCE subroutine). This works better than computing the
Sobol indices directly from the SC expansion in the case of the
dimension-adaptive sampler.</p>

<p>Method: J.D. Jakeman et al, "Adaptive multi-index collocation
for uncertainty quantification and sensitivity analysis", 2019.
(Page 18)</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>qoi</strong> (str):
name of the Quantity of Interest for which to compute the indices</li>
<li><strong>typ</strong> (str):
Default = 'first_order'. 'all' is also possible</li>
<li><strong>**kwargs</strong> (dict):
if this contains 'samples', use these instead of the SC samples ]
in the database</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>Tuple</strong>: Mean: PCE mean
Var: PCE variance
S_u: PCE Sobol indices, either the first order indices or all indices</li>
</ul>
</div>


                            </div>
                            <div id="SCAnalysis.compute_tensor_prod_u" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SCAnalysis.compute_tensor_prod_u">#&nbsp;&nbsp</a>

                <div class="decorator">@staticmethod</div>

            <span class="def">def</span>
            <span class="name">compute_tensor_prod_u</span><span class="signature">(xi, wi, u, u_prime)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">compute_tensor_prod_u</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">wi</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">u_prime</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate tensor products of weights and collocation points</span>
<span class="sd">        with dimension of u and u&#39;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xi (array of floats): 1D colloction points</span>
<span class="sd">        wi (array of floats): 1D quadrature weights</span>
<span class="sd">        u  (array of int): dimensions</span>
<span class="sd">        u_prime (array of int): remaining dimensions (u union u&#39; = range(N))</span>

<span class="sd">        Returns</span>
<span class="sd">        dict of tensor products of weight and points for dimensions u and u&#39;</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># tensor products with dimension of u</span>
        <span class="n">xi_u</span> <span class="o">=</span> <span class="p">[</span><span class="n">xi</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">u</span><span class="p">]</span>
        <span class="n">wi_u</span> <span class="o">=</span> <span class="p">[</span><span class="n">wi</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">u</span><span class="p">]</span>

        <span class="n">xi_d_u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">xi_u</span><span class="p">)))</span>
        <span class="n">wi_d_u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">wi_u</span><span class="p">)))</span>

        <span class="c1"># tensor products with dimension of u&#39; (complement of u)</span>
        <span class="n">xi_u_prime</span> <span class="o">=</span> <span class="p">[</span><span class="n">xi</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">u_prime</span><span class="p">]</span>
        <span class="n">wi_u_prime</span> <span class="o">=</span> <span class="p">[</span><span class="n">wi</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">u_prime</span><span class="p">]</span>

        <span class="n">xi_d_u_prime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">xi_u_prime</span><span class="p">)))</span>
        <span class="n">wi_d_u_prime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">wi_u_prime</span><span class="p">)))</span>

        <span class="k">return</span> <span class="n">xi_d_u</span><span class="p">,</span> <span class="n">wi_d_u</span><span class="p">,</span> <span class="n">xi_d_u_prime</span><span class="p">,</span> <span class="n">wi_d_u_prime</span>
</pre></div>

        </details>

            <div class="docstring"><p>Calculate tensor products of weights and collocation points
with dimension of u and u'</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><p><strong>xi (array of floats)</strong> (1D colloction points):</p></li>
<li><p><strong>wi (array of floats)</strong> (1D quadrature weights):</p></li>
<li><p><strong>u  (array of int)</strong> (dimensions):</p></li>
<li><p><strong>u_prime (array of int)</strong> (remaining dimensions (u union u' = range(N))):</p></li>
<li><p><strong>Returns</strong></p></li>
<li><strong>dict of tensor products of weight and points for dimensions u and u'</strong></li>
</ul>

<hr />
</div>


                            </div>
                            <div id="SCAnalysis.compute_marginal" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SCAnalysis.compute_marginal">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">compute_marginal</span><span class="signature">(self, qoi, u, u_prime, diff)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">compute_marginal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qoi</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">u_prime</span><span class="p">,</span> <span class="n">diff</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes a marginal integral of the qoi(x) over the dimension defined</span>
<span class="sd">        by u_prime, for every x value in dimensions u</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        - qoi (str): name of the quantity of interest</span>
<span class="sd">        - u (array of int): dimensions which are not integrated</span>
<span class="sd">        - u_prime (array of int): dimensions which are integrated</span>
<span class="sd">        - diff (array of int): levels</span>

<span class="sd">        Returns</span>
<span class="sd">        - Values of the marginal integral</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># 1d weights and points of the levels in diff</span>
        <span class="n">xi</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">xi_1d</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">diff</span><span class="p">)[</span><span class="n">n</span><span class="p">]]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)]</span>
        <span class="n">wi</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">wi_1d</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">diff</span><span class="p">)[</span><span class="n">n</span><span class="p">]]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)]</span>

        <span class="c1"># compute tensor products and weights in dimension u and u&#39;</span>
        <span class="n">xi_d_u</span><span class="p">,</span> <span class="n">wi_d_u</span><span class="p">,</span> <span class="n">xi_d_u_prime</span><span class="p">,</span> <span class="n">wi_d_u_prime</span> <span class="o">=</span>\
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_tensor_prod_u</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">wi</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">u_prime</span><span class="p">)</span>

        <span class="n">idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">u_prime</span><span class="p">)))</span>
        <span class="c1"># marginals h = f*w&#39; integrated over u&#39;, so cardinality is that of u</span>
        <span class="n">h</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span> <span class="o">*</span> <span class="n">xi_d_u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i_u</span><span class="p">,</span> <span class="n">xi_d_u_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">xi_d_u</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i_up</span><span class="p">,</span> <span class="n">xi_d_u_prime_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">xi_d_u_prime</span><span class="p">):</span>
                <span class="n">xi_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">xi_d_u_</span><span class="p">,</span> <span class="n">xi_d_u_prime_</span><span class="p">))[</span><span class="n">idxs</span><span class="p">]</span>
                <span class="c1"># find the index of the corresponding code sample</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi_d</span> <span class="o">==</span> <span class="n">xi_s</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1"># perform quadrature</span>
                <span class="n">q_k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">qoi</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span>
                <span class="n">h</span><span class="p">[</span><span class="n">i_u</span><span class="p">]</span> <span class="o">+=</span> <span class="n">q_k</span> <span class="o">*</span> <span class="n">wi_d_u_prime</span><span class="p">[</span><span class="n">i_up</span><span class="p">]</span><span class="o">.</span><span class="n">prod</span><span class="p">()</span>
        <span class="c1"># return marginal and the weights of dimensions u</span>
        <span class="k">return</span> <span class="n">h</span><span class="p">,</span> <span class="n">wi_d_u</span>
</pre></div>

        </details>

            <div class="docstring"><p>Computes a marginal integral of the qoi(x) over the dimension defined
by u_prime, for every x value in dimensions u</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><p><strong>- qoi (str)</strong> (name of the quantity of interest):</p></li>
<li><p><strong>- u (array of int)</strong> (dimensions which are not integrated):</p></li>
<li><p><strong>- u_prime (array of int)</strong> (dimensions which are integrated):</p></li>
<li><p><strong>- diff (array of int)</strong> (levels):</p></li>
<li><p><strong>Returns</strong></p></li>
<li><strong>- Values of the marginal integral</strong></li>
</ul>

<hr />
</div>


                            </div>
                            <div id="SCAnalysis.get_sobol_indices" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SCAnalysis.get_sobol_indices">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_sobol_indices</span><span class="signature">(self, qoi, typ=&#39;first_order&#39;)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_sobol_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qoi</span><span class="p">,</span> <span class="n">typ</span><span class="o">=</span><span class="s1">&#39;first_order&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes Sobol indices using Stochastic Collocation. Method:</span>
<span class="sd">        Tang (2009), GLOBAL SENSITIVITY ANALYSIS  FOR STOCHASTIC COLLOCATION</span>
<span class="sd">        EXPANSION.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        qoi (str): name of the Quantity of Interest for which to compute the indices</span>
<span class="sd">        typ (str): Default = &#39;first_order&#39;. &#39;all&#39; is also possible</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Either the first order or all Sobol indices of qoi</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Computing Sobol indices...&#39;</span><span class="p">)</span>
        <span class="c1"># multi indices</span>
        <span class="n">U</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;first_order&#39;</span><span class="p">:</span>
            <span class="n">P</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">powerset</span><span class="p">(</span><span class="n">U</span><span class="p">))[</span><span class="mi">0</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
            <span class="c1"># all indices u</span>
            <span class="n">P</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">powerset</span><span class="p">(</span><span class="n">U</span><span class="p">))</span>

        <span class="c1"># get first two moments</span>
        <span class="n">mu</span><span class="p">,</span> <span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_moments</span><span class="p">(</span><span class="n">qoi</span><span class="p">)</span>

        <span class="c1"># partial variances</span>
        <span class="n">D_u</span> <span class="o">=</span> <span class="p">{</span><span class="n">P</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">mu</span><span class="o">**</span><span class="mi">2</span><span class="p">}</span>

        <span class="n">sobol</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">P</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>

            <span class="c1"># complement of u</span>
            <span class="n">u_prime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
            <span class="n">D_u</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">l_norm</span><span class="p">:</span>

                <span class="c1"># expand the multi-index indices of the tensor product</span>
                <span class="c1"># (Q^1_{i1} - Q^1_{i1-1}) X ... X (Q^1_{id) - Q^1_{id-1})</span>
                <span class="n">diff_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="p">[[</span><span class="n">k</span><span class="p">,</span> <span class="o">-</span><span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">l</span><span class="p">])))</span>

                <span class="c1"># perform analysis on each Q^1_l1 X ... X Q^1_l_N tensor prod</span>
                <span class="k">for</span> <span class="n">diff</span> <span class="ow">in</span> <span class="n">diff_idx</span><span class="p">:</span>

                    <span class="c1"># if any Q^1_li is below the minimim level, Q^1_li is defined</span>
                    <span class="c1"># as zero: do not compute this Q^1_l1 X ... X Q^1_l_N tensor prod</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">l_norm_min</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>

                        <span class="c1"># mariginal integral h, integrate over dimensions u&#39;</span>
                        <span class="n">h</span><span class="p">,</span> <span class="n">wi_d_u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_marginal</span><span class="p">(</span><span class="n">qoi</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">u_prime</span><span class="p">,</span> <span class="n">diff</span><span class="p">)</span>

                        <span class="c1"># square result and integrate over remaining dimensions u</span>
                        <span class="k">for</span> <span class="n">i_u</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">wi_d_u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                            <span class="n">D_u</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">diff</span><span class="p">))</span> <span class="o">*</span> <span class="n">h</span><span class="p">[</span><span class="n">i_u</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">wi_d_u</span><span class="p">[</span><span class="n">i_u</span><span class="p">]</span><span class="o">.</span><span class="n">prod</span><span class="p">()</span>

                <span class="c1">#D_u[u] = D_u[u].flatten()</span>

            <span class="c1"># all subsets of u</span>
            <span class="n">W</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">powerset</span><span class="p">(</span><span class="n">u</span><span class="p">))[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># partial variance of u</span>
            <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">W</span><span class="p">:</span>
                <span class="n">D_u</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">-=</span> <span class="n">D_u</span><span class="p">[</span><span class="n">w</span><span class="p">]</span>

            <span class="c1"># compute Sobol index, only include points where D &gt; 0</span>
            <span class="c1"># sobol[u] = D_u[u][idx_gt0]/D[idx_gt0]</span>
            <span class="n">sobol</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">D_u</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">/</span> <span class="n">D</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;done.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sobol</span>
</pre></div>

        </details>

            <div class="docstring"><p>Computes Sobol indices using Stochastic Collocation. Method:
Tang (2009), GLOBAL SENSITIVITY ANALYSIS  FOR STOCHASTIC COLLOCATION
EXPANSION.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><p><strong>qoi (str)</strong> (name of the Quantity of Interest for which to compute the indices):</p></li>
<li><p><strong>typ (str)</strong> (Default = 'first_order'. 'all' is also possible):</p></li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>Either the first order or all Sobol indices of qoi</strong></li>
</ul>
</div>


                            </div>
                            <div id="SCAnalysis.get_uncertainty_amplification" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SCAnalysis.get_uncertainty_amplification">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_uncertainty_amplification</span><span class="signature">(self, qoi)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_uncertainty_amplification</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qoi</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes a measure that signifies the ratio of output to input</span>
<span class="sd">        uncertainty. It is computed as the (mean) Coefficient of Variation (V)</span>
<span class="sd">        of the output divided by the (mean) CV of the input.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        qoi (string): name of the Quantity of Interest</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        blowup (float): the ratio output CV / input CV</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">mean_f</span><span class="p">,</span> <span class="n">var_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_moments</span><span class="p">(</span><span class="n">qoi</span><span class="p">)</span>
        <span class="n">std_f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">var_f</span><span class="p">)</span>

        <span class="n">mean_xi</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">std_xi</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">CV_xi</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">params_distribution</span><span class="p">:</span>
            <span class="n">E</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">E</span><span class="p">(</span><span class="n">param</span><span class="p">)</span>
            <span class="n">Std</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">Std</span><span class="p">(</span><span class="n">param</span><span class="p">)</span>
            <span class="n">mean_xi</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
            <span class="n">std_xi</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Std</span><span class="p">)</span>
            <span class="n">CV_xi</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Std</span> <span class="o">/</span> <span class="n">E</span><span class="p">)</span>

        <span class="n">CV_in</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">CV_xi</span><span class="p">)</span>
        <span class="n">CV_out</span> <span class="o">=</span> <span class="n">std_f</span> <span class="o">/</span> <span class="n">mean_f</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">CV_out</span><span class="p">)</span> <span class="o">==</span> <span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">CV_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">CV_out</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
        <span class="n">blowup</span> <span class="o">=</span> <span class="n">CV_out</span> <span class="o">/</span> <span class="n">CV_in</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;-----------------&#39;</span><span class="p">)</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Mean CV input = </span><span class="si">%.4f</span><span class="s1"> </span><span class="si">%%</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="n">CV_in</span><span class="p">,</span> <span class="p">))</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Mean CV output = </span><span class="si">%.4f</span><span class="s1"> </span><span class="si">%%</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="n">CV_out</span><span class="p">,</span> <span class="p">))</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s1">&#39;Uncertainty amplification factor = </span><span class="si">%.4f</span><span class="s1">/</span><span class="si">%.4f</span><span class="s1"> = </span><span class="si">%.4f</span><span class="s1">&#39;</span> <span class="o">%</span>
            <span class="p">(</span><span class="n">CV_out</span><span class="p">,</span> <span class="n">CV_in</span><span class="p">,</span> <span class="n">blowup</span><span class="p">))</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;-----------------&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">blowup</span>
</pre></div>

        </details>

            <div class="docstring"><p>Computes a measure that signifies the ratio of output to input
uncertainty. It is computed as the (mean) Coefficient of Variation (V)
of the output divided by the (mean) CV of the input.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>qoi (string)</strong> (name of the Quantity of Interest):</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>blowup (float)</strong> (the ratio output CV / input CV):</li>
</ul>
</div>


                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="base.html#BaseAnalysisElement">easyvvuq.analysis.base.BaseAnalysisElement</a></dt>
                                <dd id="SCAnalysis.element_category" class="function"><a href="base.html#BaseAnalysisElement.element_category">element_category</a></dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="powerset">
                            <div class="attr function"><a class="headerlink" href="#powerset">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">powerset</span><span class="signature">(iterable)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">powerset</span><span class="p">(</span><span class="n">iterable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;powerset([1,2,3]) --&gt; () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)</span>

<span class="sd">    Taken from: https://docs.python.org/3/library/itertools.html#recipes</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    iterable : iterable</span>
<span class="sd">        Input sequence</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">s</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">combinations</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
</pre></div>

        </details>

            <div class="docstring"><p>powerset([1,2,3]) --> () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)</p>

<p>Taken from: https://docs.python.org/3/library/itertools.html#recipes</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>iterable</strong> (iterable):
Input sequence</li>
<li><strong>Returns</strong></li>
</ul>

<hr />
</div>


                </section>
                <section id="lagrange_poly">
                            <div class="attr function"><a class="headerlink" href="#lagrange_poly">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">lagrange_poly</span><span class="signature">(x, x_i, j)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">lagrange_poly</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x_i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Lagrange polynomials used for interpolation</span>

<span class="sd">    l_j(x) = product(x - x_m / x_j - x_m) with 0 &lt;= m &lt;= k</span>
<span class="sd">                                               and m !=j</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : float</span>
<span class="sd">        location at which to compute the polynomial</span>

<span class="sd">    x_i : list or array of float</span>
<span class="sd">        nodes of the Lagrange polynomials</span>

<span class="sd">    j : int</span>
<span class="sd">        index of node at which l_j(x_j) = 1</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        l_j(x) calculated as shown above.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">l_j</span> <span class="o">=</span> <span class="mf">1.0</span>

    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x_i</span><span class="p">)):</span>

        <span class="k">if</span> <span class="n">m</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
            <span class="n">denom</span> <span class="o">=</span> <span class="n">x_i</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">x_i</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>
            <span class="n">nom</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">x_i</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>

            <span class="n">l_j</span> <span class="o">*=</span> <span class="n">nom</span> <span class="o">/</span> <span class="n">denom</span>

    <span class="k">return</span> <span class="n">l_j</span>
    <span class="c1"># implementation below is more beautiful, but slower</span>
    <span class="c1"># x_i_ = np.delete(x_i, j)</span>
    <span class="c1"># return np.prod((x - x_i_) / (x_i[j] - x_i_))</span>
</pre></div>

        </details>

            <div class="docstring"><p>Lagrange polynomials used for interpolation</p>

<p>l_j(x) = product(x - x_m / x_j - x_m) with 0 &lt;= m &lt;= k
                                           and m !=j</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>x</strong> (float):
location at which to compute the polynomial</li>
<li><strong>x_i</strong> (list or array of float):
nodes of the Lagrange polynomials</li>
<li><strong>j</strong> (int):
index of node at which l_j(x_j) = 1</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>float</strong>: l_j(x) calculated as shown above.</li>
</ul>
</div>


                </section>
                <section id="setdiff2d">
                            <div class="attr function"><a class="headerlink" href="#setdiff2d">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">setdiff2d</span><span class="signature">(X, Y)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">setdiff2d</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the difference of two 2D arrays X and Y</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X : 2D numpy array</span>
<span class="sd">    Y : 2D numpy array</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    The difference X \\ Y as a 2D array</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">X</span><span class="p">))</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">Y</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">diff</span><span class="p">))</span>
</pre></div>

        </details>

            <div class="docstring"><p>Computes the difference of two 2D arrays X and Y</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><p><strong>X</strong> (2D numpy array):</p></li>
<li><p><strong>Y</strong> (2D numpy array):</p></li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>The difference X \ Y as a 2D array</strong></li>
</ul>
</div>


                </section>
    </main>
            <script>/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();</script>
            <script>
                function escapeHTML(html) {
                    return document.createElement('div').appendChild(document.createTextNode(html)).parentNode.innerHTML;
                }

                const originalContent = document.querySelector("main.pdoc");
                let currentContent = originalContent;

                function setContent(innerHTML) {
                    let elem;
                    if (innerHTML) {
                        elem = document.createElement("main");
                        elem.classList.add("pdoc");
                        elem.innerHTML = innerHTML;
                    } else {
                        elem = originalContent;
                    }
                    if (currentContent !== elem) {
                        currentContent.replaceWith(elem);
                        currentContent = elem;
                    }
                }

                function getSearchTerm() {
                    return (new URL(window.location)).searchParams.get("search");
                }

                const searchBox = document.querySelector(".pdoc input[type=search]");
                searchBox.addEventListener("input", function () {
                    let url = new URL(window.location);
                    if (searchBox.value.trim()) {
                        url.hash = "";
                        url.searchParams.set("search", searchBox.value);
                    } else {
                        url.searchParams.delete("search");
                    }
                    history.replaceState("", "", url.toString());
                    onInput();
                });
                window.addEventListener("popstate", onInput);


                let searchIndex, searchErr;

                async function initialize() {
                    let docs;
                    try {
                        let resp = await fetch("../../search.json");
                        docs = await resp.json();
                    } catch (e) {
                        searchErr = "Cannot fetch search index.";
                        throw e;
                    }

                    // Also split on html tags. this is a cheap heuristic, but good enough.
                    elasticlunr.tokenizer.setSeperator(/[\s\-.;&]+|<[^>]*>/);

                    if (docs._isPrebuiltIndex) {
                        console.info("using precompiled search index");
                        searchIndex = elasticlunr.Index.load(docs);
                    } else {
                        console.time("building search index");
                        searchIndex = elasticlunr(function () {
                            this.addField('qualname');
                            this.addField('fullname');
                            this.addField('doc');
                            this.setRef('fullname');
                        });
                        for (let doc of docs) {
                            searchIndex.addDoc(doc);
                        }
                        console.timeEnd("building search index");
                    }
                    onInput();

                    document.querySelector("nav.pdoc").addEventListener("click", e => {
                        if (e.target.hash) {
                            searchBox.value = "";
                            searchBox.dispatchEvent(new Event("input"));
                        }
                    });
                }

                function onInput() {
                    setContent((() => {
                        const search = getSearchTerm();
                        if (!search) {
                            return null
                        }
                        if (searchErr) {
                            return `<h3>Error: ${searchErr}</h3>`
                        }
                        if (!searchIndex) {
                            return "<h3>Searching...</h3>"
                        }

                        window.scrollTo({top: 0, left: 0, behavior: 'auto'});

                        const results = searchIndex.search(search, {
                            fields: {
                                qualname: {boost: 4},
                                fullname: {boost: 2},
                                doc: {boost: 1},
                            },
                            expand: true
                        });

                        let html;
                        if (results.length === 0) {
                            html = `No search results for '${escapeHTML(search)}'.`
                        } else {
                            html = `<h4>${results.length} search result${results.length > 1 ? "s" : ""} for '${escapeHTML(search)}'.</h4>`;
                        }
                        for (let result of results.slice(0, 10)) {
                            let doc = result.doc;
                            let url = `../../${doc.modulename.replaceAll(".", "/")}.html`;
                            if (doc.qualname) {
                                url += `#${doc.qualname}`;
                            }

                            let heading;
                            switch (result.doc.type) {
                                case "function":
                                    heading = `<span class="def">${doc.funcdef}</span> <span class="name">${doc.fullname}</span><span class="signature">(${doc.parameters.join(", ")})</span>`;
                                    break;
                                case "class":
                                    heading = `<span class="def">class</span> <span class="name">${doc.fullname}</span>`;
                                    break;
                                default:
                                    heading = `<span class="name">${doc.fullname}</span>`;
                                    break;
                            }
                            html += `
                        <section class="search-result">
                        <a href="${url}" class="attr ${doc.type}">${heading}</a>
                        <div class="docstring">${doc.doc}</div>
                        </section>
                    `;

                        }
                        return html;
                    })());
                }

                if (getSearchTerm()) {
                    initialize();
                    searchBox.value = getSearchTerm();
                    onInput();
                } else {
                    searchBox.addEventListener("focus", initialize, {once: true});
                }

                searchBox.addEventListener("keydown", e => {
                    if (["ArrowDown", "ArrowUp", "Enter"].includes(e.key)) {
                        let focused = currentContent.querySelector(".search-result.focused");
                        if (!focused) {
                            currentContent.querySelector(".search-result").classList.add("focused");
                        } else if (
                            e.key === "ArrowDown"
                            && focused.nextElementSibling
                            && focused.nextElementSibling.classList.contains("search-result")
                        ) {
                            focused.classList.remove("focused");
                            focused.nextElementSibling.classList.add("focused");
                            focused.nextElementSibling.scrollIntoView({
                                behavior: "smooth",
                                block: "nearest",
                                inline: "nearest"
                            });
                        } else if (
                            e.key === "ArrowUp"
                            && focused.previousElementSibling
                            && focused.previousElementSibling.classList.contains("search-result")
                        ) {
                            focused.classList.remove("focused");
                            focused.previousElementSibling.classList.add("focused");
                            focused.previousElementSibling.scrollIntoView({
                                behavior: "smooth",
                                block: "nearest",
                                inline: "nearest"
                            });
                        } else if (
                            e.key === "Enter"
                        ) {
                            focused.querySelector("a").click();
                        }
                    }
                });
            </script>
</body>
</html>